/**
 * ude.js -- Universal Doc Editor
 *  Copyright (C) 2023  Quentin CORNWELL
 *  
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/**
 *
 *   <p>The UDE class implements an HTML editor using the browser's contenteditable functionality.</p>
 *   <p>UDE stands for Universal Doc Editor as the editor calls specific modules to handle a 
 *   wide-range of document elements and editing goals such as text, buttons, formula, tables, graphics, 
 *   lined-text for CSS, js, server commands, api calls, JSON data.</p>
 *
 *   <p>UDE requires the DOM class, which encapsulates access to the DOM, and an instance may be provided by the data source.
 *   Other modules are loaded as required : UDEcalc for calculations and modules for handling specific UD types.</p>
 *
 *   <p>The class's methods are grouped by process as follows :
 *      <li>- Filtering and converting User actions to Edit events : user_event() calls key_event()</li> 
 *      <li>- Dispatching Edit events to specific modules : edit_event()</li> 
 *      <li>- Local or default handling of Edit events</li> 
 *      <li>- Informing View-Model of a change of state of an element</li> 
 *      <li>- Allocating time for background tasks : calculation updates and mouse/touch event qualification</li> 
 *      <li>- Executing inline commands </li> 
 *      <li>- Rollbacks</li> 
 *   </p>
 *   <p>User actions are mouse/touch events, key input, clipboard events and drag/drop. Some actions use the browser's
 *   default editing functionnality which the editor may just monitor so as to inform the View Model. For other actions
 *   the editor's own editing functions are used.</p>
 *
 *   <p>Edit events are load, change, insert, replace, click, drag, cut, copy.</p>
 *
 *   <p>View-model element state changes are focus, (content) changed, tag changed, create, delete,</p>  
 *   
 *     
 */
 
 /**
  * @property {string}  ude_datasrc     Id of default container element (ex a table) for all formula within the element 
  * @property {string}  ude_autosave    Automatically save element if on or absent
  * @property {object}  ude_stage       Use 2-stage editing on this element
  */
var UDE_attributes = [ // These are the attributes of individual HTML elements. It is planned that they be prefixed with "data-"
    "ude_datasrc",     // Default container element (ex a table) for all formula within the element 
    "ude_autosave",    // On or absent : automatically save element, Off : don't automatically save element 
    "ude_stage",       // Use 2-stage editing on this element
    "ude_onvalid",     // Action when field is valid DEV
    "ude_oninvalid",   // Action when field is invalid or abandonned DEV
    "ude_bind",        // Id of the element to update when saving element store data. If none, then the parent with ud_oid is saved 
    "ude_place",       // Placeholder text for element,
    "ude_onvalid",     // If stage on, registered action triggered when element has a valid content
    "ude_oninvalid",   // If stage on, registered action triggered when elemenet has an invalid content
];

/**
 * JS class UDE
 */
/**
 *  The UDE JS class implements an HTML editor using the browser's contenteditable functionality.
 *  <p>Its tasks are the following :
 *      <li>- Filter and convert User actions to Edit events : user_event() calls key_event()</li> 
 *      <li>- Dispatch Edit events to specific modules : edit_event()</li> 
 *      <li>- Provide default  handling of Edit events</li> 
 *      <li>- Inform View-Model of a change of state of an element</li> 
 *      <li>- Allocate time for background tasks : calculation updates and mouse/touch event qualification</li> 
 *      <li>- Execute inline commands </li> 
 *      <li>- Provide a rollback mecanism</li> 
 *   </p>
 */ 
class UDE
{
 /**
  * @property {object}  parent          Object that built instance and porvides a viewEvent method for handling events generated by this object 
  * @property {object}  modules         Table of editor modules, their state and active instance
  * @property {object}  ticks           100ms-resolution counter
  */    
  // Parameters
  useCE = true;        // use in-built content editing
  bookChangesTimeout = 5;
  /* tickJump = 30;    // Obsolete */
  // Edit event dispatching
  modules = {
        // enscapulation of DOM
        //dom:{ src:"intern", state:"loaded", onload:'dataSource.dom', instance:null}, 
        // HTML calculator      
        //calc:{ src:"intern", state:"loaded", onload:'new UDEcalc( this.dom, this);', instance:null, className:'UDEcalc'},
        // UDEtable class for table edition
        'div.table':{ src:"app/elements/udetable.js", state:"required", onload:'new UDEtable( window.ude.dom, window.ude);', instance:null, extags:'div.table', className:'UDEtable'},
        // UDEtext class for line text edition
        'div.linetext':{ src:"app/elements/udetext.js", state:"required", onload:'new UDEtext( window.ude.dom, window.ude);', instance:null, extags:'div.linetext', className:'UDEtext'}, 
        // UDElist class for list edition
        'div.list':{ src:"app/elements/udelist.js", state:"required", onload:"new UDElist( window.ude.dom, window.ude);", instance:null, extags:'div.list', className:'UDElist'},
        // UDEdraw class for graphics edition        
        'div.graphic':{ src:"app/elements/udedraw.js", state:"required", onload:'new UDEdraw( window.ude.dom, window.ude);', instance:null, extags:'div.graphic', className:'UDEdraw'},
        // UDEchart class for chart display
        'div.chart':{ src:"app/elements/udechart.js", state:"required", onload:"new UDEchart( window.ude);", instance:null, extags:'div.chart', className:'UDEchart'},
        'Udapi':{ src:"app/$$$/udapi.js", state:"required", onload:"new UDapi( window.ude);", instance:null, extags:'', className:'UDapi'},
        'div.html':{ src:"app/elements/udehtml.js", state:"required", onload:"new UDEhtml( window.ude);", instance:null, extags:'div.html', className:'UDEhtml'},
        'div.connector':{ src:"app/elements/udeconnector.js", state:"required", onload:"new UDEconnector( window.ud);", instance:null, extags:'div.connector', className:'UDEconnector'},
        'div.video':{ src:"app/elements/udevideo.js", state:"required", onload:"new UDEvideo( window.ud);", instance:null, extags:'div.video', className:'UDEvideo'},
        /* 'siteExtract':{ src:"modules/connectors/udcsiteextract.js", state:"required", onload:"new UDC_siteExtract( window.ud);", instance:null, extags:'div.connector.site', className:'UDC_siteExtract'}, */       
    }; 
    virtualKeyboardMaxTime = 15; // ms

    
  // Conversion of User events to Edit events
  // Helpers
  menuManager = null;           // Menu manager object
  layoutManager = null;         // Layout manager object
  // 
  editElement = null;           // Element which has focus
  // 2-stage editing
  editingElement = null;        // element being edited with 2 stage editing
  editRestoreHTML = null;       // content of element before editing started
  editRestoreAttr = {};         // element attributes to restore after editing
  
  // Background tasks
  ticks = 0;           // time counter
  // Shortcuts to other modules
  registerAPI = null;  // UD_resources to access parameters
  dom = null;          // DOM object for functions on DOM
  calc = null;         // UDEcalc object for calculations
  tableEd = null;      // UDEtable object for table editing
  draw = null;         // UDEdraw object for graphical editing
  textEd = null;       // UDEtext object for line text editing
  clipboard = null;    // UDEclipboard object for managing clipboard
  // Document element ids
  topOid = "";
  container = null;
  dataSource = null;
  updateForm = "updateform";
  modified = false;
  directions = [ "None", "Up", "Down", "Left", "Right"];
  escapedChars = { ">":"&"+"gt;", "<":"&"+"lt"};
  lastChar = "";
  //tableBuffers = {};
  
  lastMouseEvent =  null;
  lastMouseEvent = 0;
  stylePopup = null;
  drawMouse = null;
  touchMove = false;
  
  externalExchange = { request: null, reply: null};
  
  // calc stuff
  dependencies = null;
  needUpdate = new Array();
  lockNeedUpdate = false;
  
  // Operationnal mode
  mode = "";
  isMobile = false;
  forceStagedEditing = false;
  tabletMode = false;
  maxElementTopOffset = -1;
  keyDownTime = 0;
  keyUpTime = 0;
  mouseDownTime = 0;
  mouseUpTime = 0;
  averageKeyboardTime = 17;  
  ignoreKeyup = false;
  watchElementForChange = null;     // context menu activated on this element
  watchElementTextContent = "";     // so check if content changes (eg Spellchecker)
  emulateMobile = false;            // scroll mode for mobile emulation
  elementToScroll = null;           // element to scroll
  lastClickPosition = {x:-1, y:-1}  // reference to compute scroll
  
  
  // Temporary input field management
  inputField = null;                // element being edited
  replacedElement = null;           // element being used for editing
  displayToRestore = "block";       
  clipboardHandler = null;
  
  // Inline command management
  enterCommand = "/!";
  endCommand = "!/";   // or Escape
  commandMode = false;
  command = "";
    
  // Editable or not
  nonEditableClasses = ["Noedit"];
  
  // Path for include
  includePath = "/upload/smartdoc/";
  testing = false;
  
  // Modules
  
  dummy = "...";                   // dummy text or busy
  
  // Constructor
  constructor( topElement, source, ticks=0)
  {
        if ( typeof process == 'object') {
            this.testing = true;
            let DOM = window.DOM;
            let UDEcalc = window.UDEcalc;
        }
      
        this.container = topElement;
        this.dataSource = source;
        // Grab shortcuts to other modules
        if ( source && typeof source.dom == "object") this.dom = source.dom;
        else this.dom = new DOM( topElement, this);
        this.calc = new UDEcalc( this.dom, this);
        this.registerAPI = window.UD_resources;
        // Store mode
        this.mode = $$$.dom.textContent( 'UD_mode');
        // Publish UDE, required for event handlers         
        window.ude = this;
        // Setup menu manager
        if ( typeof UDE_menu != "undefined") { 
            this.menuManager = new UDE_menu( this);
        }
        // Setup Layout manager
        if ( typeof UDE_layout != "undefined") { 
            this.layoutManager = new UDE_layout( this);
        }
         
        // Load API functions
        if ( typeof API != "undefined" && API) {
            API.addFunctions( this, [ 
                'changeTagOnCurrent', 'changeTag', 'changeClassOnCurrent', 'changeSubType', 
                'changeClass', 'toggleClass', 'setAttribute', 'insertElement', 'updateElement', 'updateTable', 'removeElement', 'followScroll', 
                'initialiseElement', 'loadScript', 'getEditType', 
                'setChanged', 'insertTextAtCursor', 'insertHTMLatCursor',
                'isLongClick', 'dispatchEditEvent', 'clearClasses',
                'requires2stageEditing', 'leave2stageEditing', 'is2stageEditing'
            ]);
            API.setupUDElinks( this);
        }
        // SET UP EVENT HANDLERS
        if ( typeof UDEclickHandler != "undefined") this.clickHandler = new UDEclickHandler( this);
        else this.clickEvent( { type:"start"});
        this.keyEvent( { type:"start"});
        this.pointEvent( {type:"start"});
        this.dataActionEvent( {type:"start"});
        let scroll = this.dom.element(  "scroll");
        if ( scroll) { 
            scroll.addEventListener( 'scroll', function (event) { window.ude.scrollEvent( event);});            
        }

        // Catch Drag and drop events in columns
        let leftColumn = document.getElementById( 'leftColumn');
        let rightColumn = document.getElementById( 'rightColumn');
        if ( leftColumn && rightColumn)
        {
            leftColumn.addEventListener('dragstart', function (event) { window.ude.dataActionEvent( event);});
            rightColumn.addEventListener('dragstart', function (event) { window.ude.dataActionEvent( event);});
            leftColumn.addEventListener('dragend', function (event) { window.ude.dataActionEvent( event);});
            rightColumn.addEventListener('dragend', function (event) { window.ude.dataActionEvent( event);});
            leftColumn.addEventListener('drop', function (event) { window.ude.dataActionEvent( event);});
            rightColumn.addEventListener('drop', function (event) { window.ude.dataActionEvent( event);});
        }
        // 2DO set contenteditable
        // Set up exchange with external modules OBSOLETE
        /*     
        this.externalExchange.request = document.getElementById( 'UDErequest');
        this.externalExchange.reply = document.getElementById( 'UDEreply');
        */ 
        // Set up 100ms tick 
        if ( typeof ticks != "undefined") this.ticks = ticks;
        setInterval( function(self) {return function() {self.tick();}}(this), 100); 
    
        // Set paragraph seperator
        if ( this.useCE && !this.testing) document.execCommand('defaultParagraphSeparator', false, 'p');
            
        // Display caret if editable
        if ( !this.testing
          && this.container.getAttribute( 'contenteditable')
          && this.container.getAttribute( 'contenteditable').toLowerCase() == "true"
        )
        {
            if ( !this.dom.cursor.restore())
            {
                // No cursor saved, so go to top of page              
                this.dom.cursor.HTMLelement = null;
                window.scrollTo( 0, 0);
                // Set cursor (on 1st element for the moment .. later saved position)
                var children = this.container.childNodes;
                var safe =  10;
                for ( let childi= 0; childi < children.length; childi++) {
                    let child = children[ childi];
                    if  ( child && child.nodeType == 1) {
                        let classList = child.classList;
                        if ( !classList.contains( 'hidden') && !classList.contains( 'system')) {
                            this.dom.cursor.HTMLelement = child; 
                            break;
                        }
                    }
                }
                if ( this.dom.cursor.HTMLelement) {
                    // Move cursor to lowest HTML element starting from top element
                    while ( this.dom.cursor.HTMLelement.tagName == "DIV" && --safe) 
                    {
                        if ( this.dom.elements( "*", this.dom.cursor.HTMLelement).length)
                          this.dom.cursor.HTMLelement = this.dom.elements( "*", this.dom.cursor.HTMLelement)[0];
                        else break;
                    }
                }
                if ( this.dom.cursor.HTMLelement) {    
                    // Get first text element of the HTML element                
                    this.dom.cursor.textElement = this.dom.cursor.HTMLelement.firstChild;
                    if ( this.dom.cursor.textElement && this.dom.cursor.textElement.nodeType != 3)
                    {
                        // in-block HTML elements
                        this.dom.cursor.HTMLelement=this.dom.cursor.HTMLelement.firstChild; 
                        this.dom.cursor.textElement = this.dom.cursor.HTMLelement.firstChild
                        // Set cursor on 1st char of found HTML and text element                    
                        this.dom.cursor.HTMLoffset = 0;
                        this.dom.cursor.set();
                    }
                }
            }            
        }
        // Make fields editable without menu in non editable views 
        let views = this.dom.elements( "div.part", "document");     
        for ( let viewi=0; viewi < views.length; viewi++) {
            let view = views[ viewi];
            if ( this.dom.attr( view, 'contenteditable') == "false") {
                let fields = this.dom.elements( "span.field", view);
                for ( let fieldi=0; fieldi < fields.length; fieldi++) {
                    let field = fields[ fieldi];
                    if ( this.dom.attr( field, "ude_edit") != "off") {
                        // Make field editable
                        this.dom.attr( field, "contenteditable", "true");
                        this.dom.attr( field, "ude_edit", "on");
                        // and without menu by default
                        if ( this.dom.attr( field, "ude_menu") == "") this.dom.attr( field, "ude_menu", "off");
                    }
                }
            }
        }
             
        // Path for loading
        if ( typeof window.UDincludePath != "undefined") this.includePath = window.UDincludePath;
        else { // DEPRECATED
        let scripts = document.getElementsByTagName("script");
        if ( scripts.length)
        {    
            let src = scripts[0].src;
            if (src.indexOf( "smartdoc_prod")>-1) this.includePath="/upload/smartdoc_prod/";
        }
        }
        
        // Get operationnal mode parameters
        let isMobileElement = this.dom.element( 'UD_device_isMobile');
        if ( isMobileElement) this.isMobile = parseInt( isMobileElement.textContent);
        // if ( this.isMobile &&  screen.innerWidth < 500) this.forceStagedEditing = true;
        
        // Load required modules
        let requiredByApp = this.dom.element( 'UD_requiredModules').textContent;
        window.ude = this;
        // Table editor
        let exTag = "div.table";        
        if ( typeof UDEtable == "undefined")
        {
            if ( requiredByApp.indexOf( 'udetable') == -1) {
                let editor = this.modules[ exTag];
                this.loadScript( editor.src, "window.ude.tableEd  = window.ude.modules['"+exTag+"']['instance']="+editor.onload, editor.className, exTag);
            }
        }
        else this.tableEd = this.modules[exTag]['instance'] = new UDEtable( this.dom, this);
        // Graphics editor
        exTag = "div.graphic";        
        if ( typeof UDEdraw == "undefined")
        {
            if ( requiredByApp.indexOf( 'udedraw') == -1) {
                let editor = this.modules[ exTag];
                this.loadScript( editor.src, "window.ude.draw  = window.ude.modules['"+exTag+"']['instance']="+editor.onload, editor.className, exTag);
            }
        }
        else this.draw = this.modules[exTag]['instance'] = new UDEdraw( this.dom, this);
        // Text editor
        exTag = "div.linetext";        
        if ( typeof UDEtext == "undefined")
        {
            if ( requiredByApp.indexOf( 'udetext') == -1) {
                let editor = this.modules[ exTag];
                this.loadScript( editor.src, "window.ude.textEd= window.ude.modules['"+exTag+"']['instance']="+editor.onload, editor.className, exTag);
            }    
        }
        else this.textEd = this.modules[exTag]['instance']= new UDEtext( this.dom, this);
        
        window.rollbacker = null;
    
    } // UDE class constructeur()
  
  
   /**
    * 1 - TIME MANAGEMENT AND BUSY STATUS
    */
  // 100 ms tick
 /**
  * Routine called every 100 ms for mouse management, watch for change on an element.
  */  
  tick()
  {    
    // just used for new this.ticks++;
    var minTicksToSave = 10;
    var updateFormName = "udeUpdate";

    // Change management - set element that was changed for tick() that will trigger change after TO
    if ( this.lastChangeElement && ( this.ticks - this.lastChangeTicks) > this.bookChangesTimeout) {
        if ( this.dom.getParentAttribute( "", "ude_autosave", this.lastChangeElement) != "off") {
            this.setChanged( this.lastChangeElement);
        } else {
            let saveable = this.dom.getSaveableParent(this.lastChangeElement);
            saveable.classList.add( 'modified');
        }    
        this.lastChangeElement = null;        
    };

    // Prompt management
    if ( this.lastMouseEvent && (this.ticks - this.lastMouseEventTime) == 2)
    {
       //console.log( this.lastMouseEvent);
       /* 2DO method prompt
       if (this.lastMouseEvent.offsetX > 0 && this.lastMouseEvent.offsetX < 40)
       {
          // Mouse in margin so display style selector
          if (this.stylePopup == null) 
          {
            this.stylePopup = document.createElement("div");
            this.container.parentNode.appendChild( this.stylePopup);
          }             
          this.stylePopup.setAttribute( 'class', 'styleSelector');
          this.stylePopup.style.position = "absolute";
          this.stylePopup.style.zIndex = 2;
          this.stylePopup.style.left = this.lastMouseEvent.offsetX + this.container.offsetLeft - 2*this.stylePopup.offsetWidth;
          this.stylePopup.style.top = this.lastMouseEvent.offsetY+this.container.offsetTop;
          this.stylePopup.innerHTML="select";
       }
       else if (this.lastMouseEvent.offsetX > 0 && this.stylePopup) 
       {
         // Remove Popup
         this.stylePopup.remove();
         this.stylePopup = null;           
       }
       */
       this.lastMouseEvent = null;
    }  
    
    if ( this.watchElementForChange)
    {
        // Generate Change event if watch element's content change
        if ( this.watchElementForChange.textContent != this.watchElementTextContent)
            this.dataSource.viewEvent( "change", this.watchElementForChange);
    }
    // Adjustments
    if ( ( this.ticks % 50) == 0) {
        // Check tablet mode
        if ( !this.forceStagedEditing && this.dom.attr( this.container, 'ude_stage') == "on") {
            this.forceStagedEditing = true;
            this.tabletMode = true;
            this.maxElementTopOffset = Math.round( window.innerHeight * 0.4);
            let header = this.dom.element( 'header');
            header.classList.add( 'hidden');
            // Add Escape button
            if ( !this.dom.element( 'escapeButton')) {
                let attr = { id: "escapeButton", class:"button"};
                let escape = this.dom.insertElement( 'span', "ESC", attr, this.dom.element( 'content'), true, true);
                escape.style.cssText = "position:absolute; z-index:20; top:50px; left:10px;";
                escape.addEventListener( 'click', function(event) { window.ude.leave2stageEditing( false)});
                // 2DO Adjust document height
                let content = this.dom.element( 'content');
                content.style.height = (content.clientHeight+50)+"px";
            }            
        }
    }
    
    this.ticks++;
    
    // Give some tme to the calculator
    if ( this.ticks > 6 && this.ticks%5 == 0) this.calc.do( 50);
  } // UDE.tick()
  
    /**
    * Return True if Editor has things to do
    */
    isBusy()
    {
        for ( let modkey in this.modules)
            if ( this.modules[ modkey].state == "loading") return true;
        return false;
    } // UDE.isBusy()
    
    
   /**
    * 2 - USER EVENT MANAGEMENT
    */    
  
   /**
    * Handle click events
    * @param {object} e The click event
    * @return {boolean} True if processed
    */
    clickEvent( e) {
        let processed = false;
        if ( e.type == "start") {
            this.dom.topElement.addEventListener( "click", function (event) { window.ude.clickEvent( event);});
            this.dom.topElement.addEventListener( "mousedown", function (event) { window.ude.clickEvent( event);});
            this.dom.topElement.addEventListener( "mouseup", function (event) { window.ude.clickEvent( event);});
            this.dom.topElement.addEventListener( "touchstart", function (event) { window.ude.clickEvent( event);});
            this.dom.topElement.addEventListener( "touchend", function (event) { window.ude.clickEvent( event);});
            return true;
        }
        if ( this.drawMouse) { this.drawMouse = null; return;}        
        e.event = e.type;
        // Find clicked element and check its not in a no edit zone
        let element = e.target;
        if ( !element && typeof e.composedPath != "undefined") {
            // Check click is not inside a No EDIT element
            let clickedElements = e.composedPath();
            for (let eli=0; eli < clickedElements.length; eli++) {
                let clickedElement = clickedElements[ eli];
                if (clickedElement.className.indexOf( "Noedit") > -1) {
                    // Cursor back to last position
                    this.dom.cursor.set(); 
                    processed = true;
                }
                if ( clickedElement.id == "document") break;
            }
        } 
        if ( element.id == "document") {
            // No clicks on container element
            e.preventDefault(); 
            return true;
        }
        // Do nothing if clicked element is inside a tool's temporary zone
        // 2DO improve if ( this.menuManager && this.menuManager.isMenu( element))
        if ( this.dom.parentAttr( element, 'id').indexOf( '_TMP') == 0) return false;
        // Get extag here and use below let exTag = this.dom.attr( element, 'exTag');
        // Clear element being watched
        this.watchElementForChange = null;
        // Check a menu action not handling this click
        if ( this.menuManager.click( element, e)) { return;}
        // Flag if element is clickable
        let clickable = false;
        if ( 
            this.dom.parentAttr( element, 'onclick') != ""
            || element.tagName == "a" || element.parentNode.tagName == "a" // check was using attr
        ) clickable = true;
        let exTag = this.dom.attr( element, "exTag");
        // FLag if element is editable
        let edit = true;
        if (
            !element
            || exTag == "div.page"
            || ( !API.testEditorAttr( element, 'ude_edit') && exTag != "input")
            || ( clickable && this.dom.attr( element.parentNode, 'ud_type') != "link")
        ) { edit = false;}
        // Filter events
        if ( e.type == "mousedown") { this.mouseDownTime = this.ticks; if ( !edit) { e.preventDefault();} return;}
        else if ( e.type == "mouseup") { this.mouseUpTime = this.ticks; if (!edit) {e.preventDefault();} return;}
        else if ( e.type == "touchstart") { this.touchMove = false; return;}
        else if ( e.type == "touchend") { if (this.touchMove) return;} // if !moved treat as click} 
        if ( !processed && edit) {
            // PROCESS A CLICK ON AN EDITABLE ELEMENT
            // Remove editing from current element
            if ( this.editElement) { this.clearClasses( this.editElement, 'editing,edcontainer,edinside');}
            this.editElement = null;
            this.dom.cursor.fetch();
            // Give editor module a chance to handle the event and break if processed 
            if ( !processed) processed = this.dispatchEvent( e, element);
            // Start 2-stage editing if required
            if ( ( this.requires2stageEditing( element))) { element = this.editingElement;}    
            if ( !processed && this.registerAPI.testEditorAttr( element, 'ude_menu'))  {            
            //if ( edit && !processed && this.dom.extraAttr( element, 'ude_menu') != "off" && this.dom.attr( element, 'ude_menu') != "off")  {
                // Display floatable menu
                let saveable = this.dom.getSaveableParent( element);
                let editable = this.dom.getEditableParent( element, this.dom.cursor.selectionInNode);
                this.toggleClass( saveable, 'editing');
                this.clearClasses( saveable, 'edcontainer');
                this.clearClasses( element, 'edinside');
                if (  this.dom.attr( editable, 'exTag').indexOf( 'span') == 0 && !editable.classList.contains( 'caption')/*&& saveable != editable*/) { 
                    this.toggleClass( saveable, 'edcontainer');
                    this.toggleClass( element, 'edinside');
                }
                this.editElement = saveable;
                if ( this.dom.cursor.selectionInNode 
                    && [ 'div.editzone'].indexOf( this.dom.attr( editable, 'exTag')) == -1
                    && !editable.classList.contains( 'linetext')
                ) {
                    // Display menu for selection
                    // let selection = { singleText: true, textNode:dom.cursor.textElement, start:dom.cursor.textOffset, end:dom.cursor.focusOffset};
                    // this.displayFloatingMenu( this.dom.getEditableParent( element), this.dom.cursor); //
                    // #2225005 setting processed as test before udeclickhandler
                    processed = this.menuManager.display( this.dom.getEditableParent( element), this.dom.cursor);
                } else if ( !this.dom.cursor.selectionMultiNode) {
                    // Display menu for element
                    //this.displayFloatingMenu( element); //
                    processed = this.menuManager.display( element);
                } else { this.menuManager.hide();}
                // No !need to climb up through parents console.log( "backcolor", this.dom.attr( element, 'computed_background-color'));
            }
            if ( !processed && this.emulateMobile) {
                // Follow mouse moves
                let me = this;
                this.dom.topElement.addEventListener('mousemove', function (event) { me.pointEvent( event);});
                let x = e.clientX; //  - Math.floor(rect.left);
                let y = e.clientY; // - Math.floor(rect.top);                
                this.lastClickPosition.x = x;
                this.lastClickPosition.y = y;
                processed = true;
            }
            // if( element.getAttribute('_updatecall')) this.dataSource.fetchElement( element);
        } else if ( element.tagName == "INPUT" || clickable) {
            // LET BROWSER PROCESS CLICKS ON NON-EDITABLE CLICKABLE ELEMENTS AND INPUT ELEMENTS 
            processed = false;
        } else if ( !clickable) { 
            // NOT EDITABLE, NOT CLICKABLE RESTORE CURSOR, CHECK FOR COLLAPSABLE AND CONSUME EVENT
            // Give element a chance to do something
            e.ud_clickable = false;
            e.ud_editable = false;
            if ( !processed) processed = this.dispatchEvent( e, element);
            // Restore cursor
            this.dom.cursor.set();
            // Menu on collapsable elements            
            let saveable = this.dom.getSaveableParent( element);
            if ( saveable.classList.contains( "collapsable")) {
                // Use floating  menu for special functions available here 
                this.editElement = null;
                //this.displayFloatingMenu(); //
                this.menuManager.hide()
                this.leave2stageEditing( true);
                this.editElement = this.dom.getSaveableParent( element);
                // this.displayFloatingMenu( this.editElement); // 
                this.menuManager.display( this.editElement);
                processed = true;
            }
        } else {
             // Remove editing from current element
            if ( this.editElement) { this.clearClasses( this.editElement, 'editing,edcontainer,edinside');}
            this.editElement = null;
            // this.displayFloatingMenu();
            this.menuManager.hide();
            this.leave2stageEditing( true);
            this.dom.cursor.clear();
        }
        if ( processed) e.preventDefault(); 
        return processed;
    }  // UDE.clickEvent()  
    
   /** 
    * @api {JS} API.isLongClick(maxMS) True of last click was longer that maxMS
    * @apiParam {integer} maxMS Maximum duration in ms of a short click
    * @apiGroup Events
    */      
    isLongClick( maxMS) {
        // Compute delay mouseDown mouseUp
        return false;
    }
    
   /**
    * Force 2 stage editing if virtual keyboard 
    */
    detectVirtualKeyboard( keyEventType) {
        if ( keyEventType == "keydown") this.keyDownTime = new Date().getTime();
        if ( keyEventType == "keyup") {
            this.keyUpTime = new Date().getTime();
            let keybTime = this.keyUpTime - this.keyDownTime;
            this.averageKeyboardTime = Math.round( this.averageKeyboardTime + ( keybTime - this.averageKeyboardTime)/2);
            if ( keybTime < this.averageKeyboardTime) {
                debug( {level:5}, "New record keyboard time !: ",keybTime, this.averageKeyboardTime);
            }
            if ( this.averageKeyboardTime < this.virtualKeyboardMaxTime) this.forceStagedEditing = true;
            else this.forceStagedEditing = false;
        }        
    }    

   /**
    * Handle keyboard events
    * @param {object} e The keyboard event
    * @return {boolean} True if processed
    */
    keyEvent( e) {
        let processed = false;
        if ( e.type == "start") {
            this.dom.topElement.addEventListener('keypress', function (event) { window.ude.keyEvent( event);});
            this.dom.topElement.addEventListener('keydown', function (event) { window.ude.keyEvent( event);});
            this.dom.topElement.addEventListener('keyup', function (event) { window.ude.keyEvent( event);});
            return true;
        }        
        let element = this.dom.cursor.fetch().HTMLelement;
        if ( element && element.id && element.id.indexOf( '_TMP') == 0) return false;
        let textElement = this.dom.cursor.textElement;
        debug( { level:6}, "Key " + e.key, e, element);
        if ( !element || this.menuManager.click( element)) return false;
        let exTag = this.dom.attr( element, 'exTag');
        let saveable = this.dom.getSaveableParent( element);
        let displayable = this.dom.getDisplayableParent( element);        
        // In some cases events on invisible elements are coming here, we have to filter
        if ( !this.testing && !this.dom.isInViewport( element)) return false;
        // Detect virtual keyboard and force stage editing if virtuel
        this.detectVirtualKeyboard( e.type);
        // Ignore false keys
        // if ( typeof e.key == "undefined" || ["Shift", "Control","Alt"].indexOf(e.key) > -1) return false;
        // Process real key  
        let key = e.key;
        if ( e.ctrlKey) { 
            key += "_ctrl";
            if ( e.shiftKey) { key += "_shift";}
        }
        let editEvent = "";        
        switch( key) {            
            case "Escape" :       
                // Abandon current operation
                // 2DO 2stageEditing( key) all the time like command line manager
                if (   this.leave2stageEditing( false) || this.inlineCommandManager( key)) processed = true;
                this.dom.cursor.clear();
                // else Let module have it        
                break;
            case "Backspace":
            case "Delete":
                if ( exTag == "input")  break;
                let elem = element;            
                if ( e.type == "keyup") {
                    // Placeholder
                    let placeholder = API.getEditorAttr( element, 'ude_place');//this.dom.attr( element, 'ude_place');
                    if ( placeholder && element.textContent == "") element.classList.add( "placeHolding");            
                    if ( this.ignoreKeyup) processed = true;
                    // else if ( this.is2stageEditing( element)) 
                    // 2-stage editing process - do nothing
                    else if ( !this.requires2stageEditing( this.dom.cursor.HTMLelement)
                            && this.dom.getParentAttribute( "", "ude_autosave", this.dom.cursor.HTMLelement) != "off")
                        // Update Rollback function
                        if ( window.rollbacker) 
                            window.rollbacker.inputEvent( {event:"change", content:element.innerHTML}, element); 
                        this.setChanged( element);                 
                }  else if ( e.type == "keydown" || e.type == "keypress" ) {
                    this.ignoreKeyup = false;
                    let cursor = this.dom.cursor;
                    if ( this.dom.cursor.selectionMultiNode) {
                        // Multiple elements selected - let browser process and indicate element has changed afterwards
                        let saveable = this.dom.getSaveableParent( element);
                        setTimeout( function() { window.ud.ude.dispatchEvent( { event:"change", multinode:"true"}, element);}, 100);
                    } else {
                        if ( cursor.selectionInNode) {
                            // Delete selection here so we can see if merging is necessary afterwards
                            // 2DO Make HTML friendly
                            if ( cursor.textElement) { 
                                let textEl = cursor.textElement;
                                let text = textEl.textContent;
                                let selStart = cursor.textOffset;
                                let selEnd = cursor.focusOffset;
                                textEl.textContent = text.substr( 0, cursor.textOffset) + text.substr( cursor.focusOffset);
                                /*
                                let text =  element.textContent;                           
                                element.textContent = text.substr( 0, cursor.textOffset) + text.substr( cursor.focusOffset);                               
                                cursor.textElement = element.childNodes[0]; // !!! Need a fct to get textNode from element and textoffset 
                                */
                            }
                            cursor.selectionInNode = false;
                            processed = true;
                            this.dom.cursor.set();
                        }    
                        if ( this.is2stageEditing( element) && element.textContent && this.dom.cursor.textOffset <= 1) {
                            // 2-stage editing - Force cursor to stay in same element
                            element.textContent = element.textContent.substring( 1);
                            this.dom.cursor.textElement = element.childNodes[0];
                            this.dom.cursor.set();
                            processed = true;                        
                        } else {
                            let textElement = this.dom.cursor.textElement;
                            let text = (textElement) ? textElement.textContent : "";
                            if ( this.dom.cursor.textOffset == 0 && key == "Backspace") {
                                // Merge up edit event        
                                editEvent = "merge up";
                            } else if ( this.dom.cursor.textOffset == text.length && key == "Delete") {
                                // Merge down edit event
                                editEvent = "merge down";
                            } else if ( element.innerHTML == "" || element.innerHTML == "<br>") {
                                // Remove edit event
                                editEvent = "remove";
                            }
                            // Avoid merging placeholder texts
                            let contentToMerge = element.innerHTML;
                            let placeholder = API.getEditorAttr( element, 'ude_place');//this.dom.attr( element, 'ude_place');
                            if ( placeholder && contentToMerge == placeholder) { this.dom.cursor.textElement.textContent = "";}
                            // Process edit event
                            if ( editEvent) { 
                                // Give editor module a chance to process then default handler
                                if ( this.dispatchEvent( {event:editEvent, saveable:saveable, displayable:displayable}, element)) processed = true;
                                else this.editEventDefault( { type:editEvent, textEl:textElement}, element);
                                processed = true; // never let browser handle merge events
                            }
                        }
                    }    
                }
                break;
                
            case "Enter" : case "Enter_shift" :
            case "\n" :
            case "\r" :
                if ( element.tagName.toLowerCase() == "input") { break;}
                if ( !this.dom.isEditable( element)) { processed = true; break;}
                // TEST bug with 2-stage editing solved by use keyup rather than keydown UNCLEAR WHY
                if ( e.type == "keydown" || e.type == "keypress") { e.preventDefault(); break;}
                let ev = { event:"newline", type:"newline", HTMLoffset:this.dom.cursor.HTMLoffset};
                if ( e.shiftKey) {
                    // Insert <br> in current HTML element
                    // Prepare BR element
                    let newLine = document.createElement( 'br');
                    let newText = document.createTextNode( '...');
                    // Get current text element & offset
                    let textEl = this.dom.cursor.textElement;
                    let textOffset = this.dom.cursor.textOffset;
                    let currentText = textEl.textContent;
                    if ( textOffset < currentText.length) {
                        // Split existing text element
                        newText.textContent = currentText.substr( textOffset);
                        textEl.textContent = currentText.substr( 0, textOffset);
                    }
                    // Insert new BR and text element
                    let siblings = Array.from( element.childNodes);
                    let textIndex = siblings.indexOf( textEl);
                    if ( textIndex < 0) break;
                    textIndex++;
                    if ( textIndex >= siblings.length) {
                        element.appendChild( newLine);
                        element.appendChild( newText);
                    } else {
                        element.insertBefore( newLine, siblings[ textIndex]); 
                        element.insertBefore( newText, siblings[ textIndex]); 
                    }
                    this.dom.cursor.textElement = newText;
                    this.dom.cursor.textOffset = 0;
                    this.dom.cursor.set();
                    this.setChanged( element);
                    processed = true;
                    // processed = ( this.dom.insertElementAtCursor('br', "") != null);
                } else  if ( 
                    !( processed = this.leave2stageEditing( true))
                    && ( element.classList.contains('caption')  // Captions handled here
                         || !( processed = this.dispatchEvent( ev, element))) 
                ) processed = this.editEventDefault( ev, element);
                break;   
            case "Tab" :
                if ( e.type == "keyup") { processed = true; break;}  
                // 2DO dispatchEvent "next" or "previous" and move to udetable
                let cursorTo = null;
                switch ( exTag) {
                    case 'th' :
                    case 'td':
                        // 2DO if shift inverse, if ctrl insertColumn event
                        if ( e.shiftKey) {
                            if ( element.previousSibling) cursorTo = element.previousSibling;
                            else {
                                // Go to previoust row
                                let row = element.parentNode;
                                if ( row) row = row.previousSibling;
                                if (row)  cursorTo = row.cells[ row.cells.length-1];
                            } 
                        } else {
                            if ( element.nextSibling) cursorTo = element.nextSibling;
                            else if ( exTag == "th") editEvent = "insert column"; 
                            else {
                                // Go to next row
                                let row = element.parentNode;
                                if ( row) row = row.nextSibling;
                                if (!row) editEvent = "newline";
                                else  cursorTo = row.cells[0];
                            } 
                        }
                        // Set cursor
                        if ( cursorTo) {
                            this.dom.cursor.setAt( cursorTo);
                            this.leave2stageEditing( true);
                            this.requires2stageEditing( cursorTo);
                            processed = true;
                        } else if ( editEvent) { 
                            if ( this.dispatchEvent( {event:editEvent, saveable:saveable, displayable:displayable}, element)) processed = true;
                            else processed = this.editEventDefault( { type:editEvent, textEl:textElement}, element);
                        }
                        break; 
                }
                break;
            //case "Tab_ctrl"
            case "Insert" :
            case "Shift":
                processed = true;
                break;            
            case "c_ctrl" : case "C_ctrl" : case "c_ctrl_shift" : case "C_ctrl_shift" :
                //processed = this.dispatchEvent( { event:"copy", type:"copy"}, element);
                //break;            
           case "v_ctrl" : case "V_ctrl" : case "v_ctrl_shift" : case "V_ctrl_shift" :
                //let data = window.clipboardData.getData('text/plain');
                //let html = window.clipboardData.getData('text/html');
                //if ( !e.shiftKey && html) { data = html;}
                //processed = this.dispatchEvent( { event:"paste", type:"paste", data:data}, element);
                //break;            
            case "x_ctrl" : case "X_ctrl" : case "x_ctrl_shift" : case "X_ctrl_shift" :
                //processed = this.dispatchEvent( { event:"cut", type:"cut"}, element);
                // processed = true;
                if ( e.type != "keydown") processed = true;
                break;            
            case "shift": case "Shift" : case "shift_shift" : case "Shift_shift" :
            case "control": case "Control" : case "Control_ctrl" : case "control_ctrl" :
            case "altGraph" : case "AltGraph" :
                processed = true;
                break;
            case "ArrowLeft" :
                if ( this.editingElement == element) {
                    if ( this.dom.cursor.textOffset <= 0) {
                        this.leave2stageEditing( true);
                        element = element.previousSibling;
                        if ( element) {
                            /*this.dom.cursor.HTMLelement = element;
                            this.dom.cursor.textElement = element.firstChild;
                            this.dom.cursor.textOffset = element.firstChild.textContent.length-1;*/
                            this.dom.cursor.setAt( element, 10000);
                            this.requires2stageEditing( element);
                        }
                    }
                    break;
                }    
                // 2DO better if element is inside menuManagerBox box  
                if ( 
                    element.classList.contains( 'objectName')
                    && this.dom.cursor.textOffset == 0  
                ) {
                    // Drown event 
                    processed = true;
                    break;
                }  
            case "ArrowRight" :
                if ( this.editingElement == element) {
                    if ( this.dom.cursor.textOffset >= (element.textContent.length - 1)) {
                        this.leave2stageEditing( true);
                        element = element.nextSibling;
                        if ( element) {
                            /*
                            this.dom.cursor.HTMLelement = element;
                            this.dom.cursor.textElement = element.firstChild;
                            this.dom.cursor.textOffset = 0;
                            this.dom.cursor.HTMLoffset = 0;
                            */
                            this.dom.cursor.setAt( element, 0);
                            this.requires2stageEditing( element);
                        }
                    }
                    break;
                }    
                // 2DO regroup Left & right, leaveStageEditing & always processed if in menuBox
                if ( 
                    key == "ArrowRight"
                    && element.classList.contains( 'objectName')
                    && this.dom.cursor.textOffset == element.textContent.length
                ) {
                    // Drown event 
                    processed = true;
                    break;
                }              
            case "ArrowUp" :
            case "ArrowDown" :
                this.leave2stageEditing( true);            
                if (e.type == "keyup" && !this.menuManager.box && !this.floaterActionPending) {
                    processed = this.edit(); // Setup editing on element at cursor
                } else {
                    let arrowEvent = { event:key, type:key, saveable:saveable, displayable:displayable};
                    processed = this.dispatchEvent( arrowEvent, element);                    
                    if ( processed) {
                        element = this.dom.cursor.fetch().HTMLelement;
                        this.requires2stageEditing( element);
                    }
                }
                break;
            case "PageUp" :
            case "PageDown" :
                if (e.type == "keyup" && !this.menuManager.box && !this.floaterActionPending) {
                    let step = 5;
                    let page = saveable.parentNode;
                    if ( this.dom.attr( page, 'exTag') == "div.page") {
                        if ( key == "PageDown") { page = page.nextSibling.nextSibling;}
                        else { page = page.previousSibling.previousSibling;}
                        let first = page.childNodes[ 0];
                        if ( first) { 
                            this.dom.cursor.setAt( first);
                            this.dom.makeVisible( first);
                        }
                    }
                    processed = true;
                    // processed = this.edit(); // Setup editing on element at cursor
                }
                break; 
            // case "<":, case ">" : 
            case "Unidentified" :
            default :
                // console.log( key);
                if ( exTag == "input") {
                    // Input element - check key is accepted, filter if not
                    let charFilter = this.dom.attr( element, 'ude_accept');
                    let validateExpr = charFilter.replace( /this/g, key);
                    if ( validateExpr && !this.calc.eval( validateExpr)) { processed = true;}
                } else if ( this.inlineCommandManager( key)) {
                    // Inline commands
                    e.preventDefault();
                } else {
                    if ( !this.editingElement) {                    
                        // Enter 2 stage editing if required or just mark as changed
                        if ( key == "Unidentified" || !this.requires2stageEditing( element)) {
                            // Update Rollback function
                            if ( window.rollbacker) window.rollbacker.inputEvent( {event:"change", content:element.innerHTML}, element);            
                            
                            // Mark element as modified
                            if ( (this.lastChangeElement && element != this.lastChangeElement) || [ ";"].indexOf( key) > -1 ) {
                                if ( this.dom.getParentAttribute( "", "ude_autosave", element) != "off") {
                                    this.setChanged( element);
                                } else {
                                    saveable.classList.add( 'modified');
                                }
                                this.lastChangeElement = null;
                            }
                            this.lastChangeElement = element;
                            this.lastChangeTicks = this.ticks;
                        }
                        if ( element.tagName == "P" && element.classList.contains( "undefined") && element.textContent.length > 20) {
                            element.classList.remove( "undefined");
                            element.classList.add( "standard");
                            this.dataSource.viewEvent( "changeTag", element); // recompute id
                        }
                    }                
                    // Event 
                    this.lastChar = key;      
                    if ( this.hasDefaultContent( element)) {
                        if ( key == "Unidentified") {
                            element.innerHTML = "";
                        } else {
                            element.innerHTML = key;
                            this.dom.cursor.textElement = element.firstChild;
                            this.dom.cursor.textOffset = 1;
                            this.dom.cursor.HTMLoffset = 1;
                            this.dom.cursor.set();
                            processed = true;
                        }
                        //if ( element.classList.contains( 'undefined')) this.changeTag( 'p', element.id);
                        //element.classList.remove( 'initialcontent');
                    }   
                }
                break; 
        }
        if ( processed) {
            debug( { level:6}, "Stopping propagation");
            this.ignoreKeyup = true;
            e.preventDefault();
            if ( typeof e.stopPropagation != "undefined") e.stopPropagation();
            if ( saveable && this.menuManager) this.menuManager.updatePosition( saveable);
        }
        return processed;
    } // UDE.keyEvent()
    
   /**
    * Handle point events (mouse & touch screen)
    * @param {object} e The click event
    * @return {boolean} True if processed
    */
   pointEvent( e) {
        let processed = false;
        if ( e.type == "start") {
            this.dom.topElement.addEventListener('mouseover', function (event) { window.ude.pointEvent( event);});
            //this.dom.topElement.addEventListener('touchstart', function (event) { window.ude.pointEvent( event);});
            //this.dom.topElement.addEventListener('touchend', function (event) { window.ude.pointEvent( event);});
            this.dom.topElement.addEventListener('mousewheel', function (event) { window.ude.pointEvent( event);});
            this.dom.topElement.addEventListener('focus', function (event) { window.ude.pointEvent( event);});
            this.dom.topElement.addEventListener('blur', function (event) { window.ude.pointEvent( event);});
            this.dom.topElement.addEventListener('touchmove', function (event) { window.ude.pointEvent( event);});               
            return true;
        }
        this.lastMouseEvent = e;
        this.lastMouseEventTime = this.ticks;
        let target = e.target; // this.dom.cursor.fetch().HTMLelement;
        let path = null;
        if ( typeof e.composedPath != "undefined") path = e.composedPath();
        else path = e.path;       
        if ( path && path[0].tagName.toLowerCase() == "canvas") {
            target = path[0];
            let saveable = this.dom.getSaveableParent( target);
            if ( this.dom.attr( saveable, 'exTag') == "div.graphic") { this.drawMouse = target;}
        }
        // Process according to type
        switch ( e.type) {
            case "touchmove" :
                if ( Object.keys( e.changedTouches).length > 2) this.touchMove = true;
                break;
            case "mousemove" :
                // Mobile emulation feature, mouse movement causes scrolling
                if ( this.emulateMobile && this.elementToScroll) {
                    // Compute mouvement
                    let x = e.clientX; //  - Math.floor(rect.left);
                    let y = e.clientY; // - Math.floor(rect.top);
                    if ( this.lastClickPosition.x > -1) {                   
                        let ix = x - this.lastClickPosition.x;
                        let iy = y - this.lastClickPosition.y;
                        let viewElement = this.dom.element( 'scroll');
                        let scrollRatio = this.elementToScroll.scrollHeight/ this.dom.attr( viewElement, 'computed_height');
                        if ( iy > 0) this.elementToScroll.style.marginTop = (- iy * scrollRatio)+"px";
                    };                    
                    processed = true;
                }
                else processed = this.dispatchEvent( {event:e.type, target:target}, target);       
                break;
            case "mouseout" :
                this.lastMouseEvent = null;
                processed = this.dispatchEvent( {event:e.type, target:target}, target);                
                break;
            case "mousedown" :
            case "touchstart" :
                let path = null;
                // processed = this.dispatchEvent( {event:e.type, target:target}, target);                
                processed = this.draw.inputEvent(e, target);
                break;
            case "mouseup" :
            case "touchend" :
                // processed = this.dispatchEvent( {event:e.type, target:target}, target);                
                if ( this.drawMouse) {
                    processed = this.draw.inputEvent(e, this.drawMouse);
                    this.drawMouse = null;
                }
                break; 
            case "mousewheel" :
                // processed = this.dispatchEvent( {event:e.type, target:target}, target);                
                if ( this.drawMouse) processed = this.draw.inputEvent(e, target);
                break;
            case "mouseover" :
            case "focus" :
            case "blur" :
            break;
        }
        if ( processed) e.preventDefault();
        return processed;   
    } // UDE.pointEvent()
 
   /**
    * Handle data action events (copy/paste, drag/drop, context menu)
    * @param {object} e The mouse event
    * @return {boolean} True if processed
    */
    dataActionEvent( e) {
        let processed = false;
        let defaultProcessing = false;
        if ( e.type == "start") {
            // Get document container events
            this.dom.topElement.addEventListener('paste', function (event) { window.ude.dataActionEvent( event);});
            this.dom.topElement.addEventListener('copy', function (event) { window.ude.dataActionEvent( event);});
            this.dom.topElement.addEventListener('cut', function (event) { window.ude.dataActionEvent( event);});
            this.dom.topElement.addEventListener('dragstart', function (event) { window.ude.dataActionEvent( event);});
            this.dom.topElement.addEventListener('dragend', function (event) { window.ude.dataActionEvent( event);});
            this.dom.topElement.addEventListener('drop', function (event) { window.ude.dataActionEvent( event);});
            this.dom.topElement.addEventListener('dragover', function (event) { window.ude.dataActionEvent( event);});
            this.dom.topElement.addEventListener('contextmenu', function (event) { window.ude.dataActionEvent( event);});
            // #2223004 Get drop events on spare space
            let middle = this.dom.element( 'middleColumn');
            if ( middle) {
                // Enable dragging elements to spare space on each side of document
                middle.addEventListener( 'dragenter', function (event) { window.ude.dataActionEvent( event);});
                middle.addEventListener( 'dragover', function (event) {  window.ude.dataActionEvent( event);});
                middle.addEventListener( 'drop', function (event) { window.ude.dataActionEvent( event);});
            }
            return true;
        }
        debug( { level:6}, "Data action", e.type, e.target, e);
        let element = this.dom.cursor.fetch().HTMLelement;
        let saveable = this.dom.getSaveableParent( element);
        let displayable = this.dom.getDisplayableParent( element);
        let target = null;
        let editEvent = null;
        let editEvents = [];
        let exTag = this.dom.attr( saveable, 'exTag');      
        switch( e.type) {
            case "paste" :
                let pastedData = "";
                let mime = "";         
                let lastClip = this.dom.element( "LastClip");
                if ( lastClip) {
                    mime = this.dom.attr( lastClip, 'cb_type');
                    pastedData = lastClip.innerHTML;
                } else {
                    let clipboardZone = document.getElementById('UDEclipboard');
                    let types = e.clipboardData.types;
                    if (((types instanceof DOMStringList) && types.contains("text/html")) 
                        || (types.indexOf && types.indexOf('text/html') !== -1)
                    ) { 
                        mime = 'text/html';
                        pastedData = e.clipboardData.getData('text/html'); 
                    } else if  (((types instanceof DOMStringList) && types.contains("text/plain")) 
                       || (types.indexOf && types.indexOf('text/plain') !== -1)
                    ) { 
                        mime = 'text/plain';
                        pastedData = e.clipboardData.getData('text/plain');
                    }
                }
                if ( this.clipboardHandler) { 
                    // 2DO Make function ude.getEditMode 
                    let editable = this.dom.getEditableParent( element);
                    let editableType = this.dom.attr( editable, 'ud_type');    
                    if ( [ 'editzone', 'viewzone'].indexOf ( editableType) > -1) { 
                        editableType = this.dom.attr( editable, 'ud_subtype');
                    }
                    let useAs = "html";
                    if ( [ "text", "linetext", "css", "json", "htmltext"].indexOf( editableType) > -1) { useAs = "text";}
                    editEvents = this.clipboardHandler.preparePasteEvents( this.clipboardHandler.preparePastedData( mime, pastedData), useAs);
                } else  if (pastedData) { editEvent = { event: "paste", type:"paste", data:pastedData, mime:mime};}
                if ( lastClip) { lastClip.remove();}
                //if ( this.clipboardHandler) this.clipboardHandler.paste( mime, pastedData);
                processed = true;
                break;
            case "copy" :
            case "cut" :
                debug (1, null, "2DO copy/cut events", e);
                //let clipId = window.clipboarder.copyTo();
                // Let browser copy styles & programs to system's clipboard
                if ( [ 'div.css', 'div.js'].indexOf( exTag) > -1 && UD_SERVER.indexOf( 'https//') == -1) 
                    defaultProcessing = true; 
                editEvent = e;
                editEvent.event = editEvent.type;
                //target = this.dom.element( clipId);
                break;
            // Drag and drop
            case "drag" :
            case "dragstart" :
                console.log( "Drag Start event", e);
                let source = e.target;
                let draggedData = "";
                let draggedId = "";
                //if ( this.dom.attr( source, 'ud_oid') && source.id[0] == "B") {
                if ( source.id.indexOf( 'move') == 0) {
                    // Dragging an editable, saveable element ... just save id
                    draggedId = source.id.substr(4);
                    draggedData = "";
                } else if ( source.tagName.toLowerCase() == "img" && source.classList.contains( 'CLIPBOARD')) {
                    // Image in clipboard
                } else if ( source.classList.contains( 'CLIPBOARD_clip')){
                    // Clip
                    draggedData = e.target.innerHTML;
                    draggedId = e.target.id;
                //} else if ( in_array( this.dom.attr( source, 'ud_type'), [ 'docThumbnail', 'dirThumbnail']))
                } else if ( this.dom.attr( source.parentNode.parentNode.parentNode.parentNode, "id") == "dir") {
                    // File or directory in directory listing
                    draggedData = this.dom.attr( source.parentNode.parentNode, 'onclick');
                    draggedId = "dir";
                }
                // console.log( draggedData);
                e.dataTransfer.setData( 'text/html', draggedData);
                e.dataTransfer.setData( 'text/plain', draggedId);
                e.stopPropagation();            
                processed = false; // We need browser to start the drag process
                break;   
            case "dragenter" :
                // 2DO check datatype & target
                target = e.target;
                if ( target.id == "middleColumn") {
                    processed = true;
                }
                break
            case "dragover" :
                // 2DO decide if draggable or not
                e.dataTransfer.dropEffect = 'move';
                processed = true;
                break;
            case "dragend" :
            case "drop" :
                console.log( "Drop event");
                console.log( e);
                let droppedData = e.dataTransfer.getData( 'text/html');
                let droppedId = e.dataTransfer.getData( 'text/plain');
                // Target is 1st element in path with an id
                let targetPath = e.composedPath();
                target = null;
                for ( let targeti=0; targeti < targetPath.length; targeti++) {
                    if ( targetPath[ targeti].id && !target) target = targetPath[ targeti];
                }
                // 2DO set cursor or allow insert to take target
                if ( target) {
                    let movedElement = this.dom.element( droppedId);
                    if ( target.id == "UD_wasteBin") {
                        // Directory listing - File dragged to waste bin
                        // Not used with new grid display
                        // Get row parent's onclick
                        let onclick = droppedData;
                        // Extract OID and build delete URI
                        let parts = onclick.split( '/');
                        let oid = parts[ 2];
                        oid = oid.split('--')[1].split('-').slice( 0, -1);
                        let oidStr = "UniversalDocElement--" + oid.join('-') + "--SP|" + ( Math.round( oid.length/2) - 1) + "|WB|1";
                        // Build temporary form 
                        let uri = "/webdesk/" + this.dom.attr( 'document', 'ud_oidchildren') + "/AJAX_modelShow/";
                        let prompt = API.translateTerm( "Are you sure ?")
                        if ( confirm(prompt)) {
                            let postData = "form=INPUT_UDE_FETCH&input_oid="+oidStr+"&iaccess=0&tlabel=owns";
                            let context = {zone: 'document', element: null, action:"fill zone", setCursor:false, ud:this.dataSource};
                            this.dataSource.udajax.serverRequest( uri, "POST", postData, context);
                        }
                    // 2DO else if ( exTag == div.page) { // Use clientX & clientY to find nearest child element}
                    } else if ( this.dom.getSaveableParent( target) == target && this.dom.attr( movedElement, 'ud_oid')) {
                        // Move an HTML saveable element
                        if ( target.id == "middleColumn") {
                            // Move to clipboard & display in spare space
                            let clipId = API.copyToClipboard( droppedId, true);
                            // 2DO display in spare space
                            // API.displayClip( clipId, "middleColumn");
                        } else if ( target.id && target.id[0] == "B") {
                            // Move before another editable element
                            let newElement = target.parentNode.insertBefore( movedElement, target);
                            // Inform UD of move so it can adjust DB name
                            this.dataSource.viewEvent( "move", newElement);
                        }
                    } else if ( droppedData) { 
                        window.clipboarder.insert( droppedId, target);
                    } // 2DO test clipboard dragging
                }
                // console.log( droppedData);
                processed = true;
                break;
            case "contextmenu" :
                console.log( e);
                // 2DO check element hasn't changed (eg Spellchecker)
                let elementsClicked = e.composedPath();
                if ( this.dom.attr( element, 'ud_oid'))  {                        
                    // Saveable element : put on watchlist for possible change
                    // until next event ?
                    this.watchElementForChange = element;
                    this.watchElementTextContent = element.textContent;
                }          
                break;
            default :
                break;
        }

        // Proceess edit events set 
        for ( let evi=0; evi < editEvents.length; evi++) {
            let editEv = editEvents[ evi];
            if ( !( this.dispatchEvent( editEv, element))) {
                this.editEventDefault( editEv, element);
            }            
        }
        // Process a single edit evet and set processed accordingly
        if ( editEvent) { 
            if ( !( processed = this.dispatchEvent( editEvent, element))) {
                processed = this.editEventDefault( editEvent, element);
            }
        }
        if ( processed && !defaultProcessing && !["copy"].indexOf( e.type) > -1 ) {
            e.preventDefault();
            if ( typeof e.stopPropagation != "undefined") e.stopPropagation();
        }    
        return processed;   
    } // UDE.dataActionEvent() 
    
    scrollEvent( e) {
        if ( this.menuManager) this.menuManager.scroll( e);
        /*
        if ( this.floater && this.floater.style.display == "block" && this.editElement) {
            // Adjust floater position
            // let bounds = this.editElement.getBoundingClientRect();
            let scrollTop = e.target.scrollTop;
            let height = this.dom.attr( this.floater.childNodes[0], 'computed_height');
            let floatTop = this.editElement.offsetTop - scrollTop - 0.5*height;
            if ( this.floaterActionPending) floatTop = this.floaterActionPending.offsetTop  - scrollTop - 0.5*height;
            if ( this.editElement.offsetParent) floatTop += this.editElement.offsetParent.offsetTop;
            this.floater.style.top = floatTop+"px";
            // floater.style.left = ( this.editElement.offsetLeft - 10)+"px";
        }
        */
    }
    
   /**
    * 2 EDIT events
    */    
    
   /**
    * Default handling of an Edit event generated by User event processing
    * @param {object} event Edit event object with type=merge up|merge down|newline|remove|paste
    * @param {HTMLelement} element The element where the event applies
    */
    editEventDefault( event, element)
    {
        if ( !element) return;
        let processed = false;
        let eventType = event.type;
        // let eventQualifier = event.qualifier;
        let saveable = this.dom.getSaveableParent( element);
        let exTag = this.dom.attr( saveable, 'exTag');
        /*
        let defaultEdit = API.json.valueByPath( UD_exTagAndClassInfo, exTag+'/defaultedit');
        if ( !defaultEdit || defaultEdit.indexOf( eventType)) {
            // Use default edit event handling
        delete lines 1229-31
        */
        let defaultTags = [ "h1", "h2", "h3", "h4", "h5", "h6", 'p', 'p.undefined', 'span', 'span.field'];
        // let actionsOnall newline setValue
        if ( defaultTags.indexOf( exTag) == -1 && eventType != "newline") return false;        
        switch( eventType) {
            case 'merge up': {
                // Check if merging is within a saveable element (siblings) or between elements
                let textEl = event.textEl;
                let siblings = Array.from( textEl.parentNode.childNodes); // Can't use dom as need text nodes
                let sibIndex = siblings.indexOf( textEl);
                let previous = element.previousSibling;
                if ( !sibIndex && previous && defaultTags.indexOf( this.dom.attr( previous, "exTag")) > -1) {
                    element = saveable;
                    previous.innerHTML += element.innerHTML;
                    this.setChanged( previous);
                    this.dom.cursor.setAt( previous, 9999);
                    element.innerHTML = "";  
                    API.removeElement( element.id);
                    processed = true;
                } else if ( sibIndex) {
                    // Merge siblings
                    let prevSib = textEl.previousSibling;
                    if ( prevSib && prevSib.nodeType == Node.ELEMENT_NODE && prevSib.tagName == "BR") {
                        prevSib.previousSibling.textContent += textEl.textContent;
                        prevSib.remove();
                        textEl.remove();
                        processed = true;
                    } else if ( prevSIb && prevSib.nodeType == Node.TEXT_NODE) {
                        prevSib.textContent += textEl.textContent;
                        textEl.remove();
                        processed = true;                        
                    }                    
                }
            break }
            case 'merge down': {
                // Check if merging is within a saveable element (siblings) or between elements
                let textEl = event.textEl;
                let siblings = Array.from( textEl.parentNode.childNodes); // Can't use dom as need text nodes
                let sibIndex = siblings.indexOf( textEl);
                let next = element.nextSibling;
                if ( !sibIndex && next && defaultTags.indexOf( this.dom.attr( next, "exTag")) > -1) {
                    element = saveable;
                    next.innerHTML = element.innerHTML + next.innerHTML;
                    this.setChanged( next);
                    this.dom.cursor.setAt( next, 0);                  
                    element.innerHTML = "";  
                    API.removeElement( element.id);
                    processed = true;
                } else if ( sibIndex) {
                    // Merge siblings
                    let nextSib = textEl.nextSibling;
                    if ( nextSib && nextSib.nodeType == Node.ELEMENT_NODE && nextSib.tagName == "BR") {
                        nextSib.nextSibling.textContent += textEl.textContent;
                        nextSib.remove();
                        textEl.remove(); 
                        processed = true;                        
                    } else if ( nextSib && nextSib.nodeType == Node.TEXT_NODE) {
                        nextSib.textContent += textEl.textContent;
                        textEl.remove(); 
                        processed = true;                        
                    }                    
                }
            break }
            case 'remove':
                element.innerHTML = ""; 
                this.source.viewEvent( "remove", element);
                processed = true;
                break
            case "insert row" :
            case "newline" :
                // Insert paragraph after current element
                let newElementType = 'div';
                let className = "undefined"; // "standard";
                let data = "";                 
                // Flag if we need to insert after or before
                let insertBefore = false; 
                if ( defaultTags.indexOf( exTag) > -1) {
                    let len = this.dom.cursor.textElement.textContent.length;
                    let cursor = this.dom.cursor.textOffset;               
                    if ( cursor == 0) insertBefore = true;
                    else if ( cursor < len) {
                        // Cursor not at end so split current paragraph
                        let html = this.dom.cursor.HTMLelement.innerHTML;
                        let htmlCursor = this.dom.cursor.computeHTMLoffset( this.dom.cursor.textElement.textContent, cursor, html);
                        data = html.substr( htmlCursor);
                        className = ""; // this.dom.attr( this.dom.cursor.HTMLelement, 'className');
                        // Update current node
                        this.dom.cursor.HTMLelement.innerHTML = html.substr( 0, htmlCursor);                 
                        if ( this.dom.getParentAttribute( "", "ude_autosave", this.dom.cursor.HTMLelement) != "off")
                        this.setChanged( this.dom.cursor.HTMLelement);
                    }
                }
                let attributes = { class:className};
                let newElement = this.insertElement( newElementType, data, attributes, saveable, !insertBefore);
                if ( !data) newElement.innerHTML = $$$.getUndefinedElementContent( newElement);
                // NO DOne in insertEl Inform VIEW-MODEL of new element
                // this.dataSource.viewEvent( "create", newElement);
                // New para becomes edited element with floating menu 
                if ( this.editElement) this.toggleClass( this.editElement, 'editing');                    
                this.editElement = null;
                // this.displayFloatingMenu();
                this.menuManager.hide();
                this.toggleClass( newElement, 'editing');
                this.editElement = newElement;
                this.dom.cursor.setAt( newElement);
                // this.displayFloatingMenu( newElement);
                this.menuManager.display( newElement);                
                processed = true;                
                break;
            case "copy" : {
                let clipId = window.clipboarder.copyTo();
                processed = true;
            break;}
            case "cut" : {
                let clipId = window.clipboarder.copyTo( "", true);
                // API.dom.removeSelection()
                processed = true;
            break;}
            case 'paste' :
                let target = this.dom.cursor.HTMLelement;
                let content = event.data;
                let targetExtag = this.dom.attr( element, 'exTag');
                // Adjust HTML content when inserting image
                if ( event.type == "image" || ( content && content.indexOf( '<img') > -1)) {
                    let srcExtract = /src="([^"]+)"/;
                    // Take only 1st image
                    let imgData = srcExtract.exec( event.data)[1];
                    // Use max height as that of current paragraph
                    let height = element.getBoundingClientRect().height*1.3;
                    content = '<img src="' + imgData + '" style="max-height:' + height + 'px;">';
                    event.type = "image";
                }
                console.log( "Default pasting", content, element);
                if ( this.dom.hasDefaultContent( target)) { target.innerHTML = content;}
                else { this.insertHTMLatCursor( content);}
                if ( targetExtag.indexOf( 'span') == 0) {
                    let textChild = document.createTextNode( "Enter to validate");
                    textChild = element.appendChild( textChild);
                    this.dom.cursor.HTMLelement = element;
                    this.dom.cursor.textElement = textChild;
                    this.dom.cursor.textOffset = 0;
                    this.dom.cursor.set(); 
                } else if ( event.type == "image") {
                    // Add layout class to elements combining text and image if not already present
                    let classes = saveable.classList;
                    for ( let classi = 0; classi < classes.length; classi++) {
                        if ( classes[ classi].indexOf( 'LAY_') > -1) break;
                        if ( classi == classes.length - 1) { saveable.classList.add( 'LAY_left');}
                    }
                }
                if ( !this.requires2stageEditing( this.dom.cursor.HTMLelement)) {
                    // Mark element as modified
                    this.setChanged( this.dom.cursor.HTMLelement);
                } 
            case "endPaste" :
                processed = true;
                break;
            case 'setValue' :
                // key contains path accept for elementId
                /*
                could just set with this.dom.attr( element, key, value)
                and $$$.setEditorAttrPermanently( element, key, value)
                */
                let valuePath = event.key;
                valuePath.unshift( element.id);
                this.dom.value( valuePath, event.value, element);
                API.setEditorAttrPermanently( element, valuePath[ valuePath.length -1], event.value)
                // this.setChanged( element);
                break;
            case "use" :
            case "idea" :
                API.insertTextAtCursor( event.data);
                break;
            case 'insert column' :
            case 'insertElement' :
            case 'copyElement' :
            case 'tab':
            case 'change':
            case 'mouseDown' :
            case 'mouseUp' :
            case 'iterate' :
            case 'enterText' :
                break;
            
        }
        if ( processed && saveable && this.menuManager) { this.menuManager.updatePosition( saveable);}
        return processed;
    } // UDE.defaultEventHandler()    
   /**
    * 3 - INTERFACE WITH MODULES
    */    
        
   /**
    * Load a script
    * @param {string} src URI of script
    * @param {string} onload JS instruction for whene script is loaded
    * @param {string} onload JS instruction for whene script is loaded
    * @param {string} className Class to instantiate on onload
    * @param {string} exTag Extended tag of HTML elements handled by this module
    */    
    loadScript( src, onload, className="", exTag = "") {
        // Get default class name for the module
        var jsClassName = src.split('/').pop().split('.',1).pop(); // ex modules/standard/inserted.js ==  inserter 
        jsClassName = jsClassName.charAt(0).toUpperCase() + jsClassName.slice(1); // Inserter
        
        if ( typeof this.modules[ src] != "undefined" && this.modules[ src]['state'] != "required")
        {
            if ( window.ud.ude.modules[ src]['state'] == "loaded")
            {
                // Module is loaded
                // Script loaded, just run initiation code
                if ( onload) doOnload( onload);
                return true;
            }
        }
        else
        { 
            // Load script
            if ( !this.testing)
            {
                // From server
                let useRequire = false; //true; // Not working yet mod still undefined 
                if ( useRequire && src.indexOf( 'Inserter') > -1) {
                    // Needs define in each module
                    let mod = src.split( '/').slice(-1)[0].split('.')[0];
                    let path = src.split('/').slice(0,-1).join('/') + '/';
                    // Store onload code : check modules extag
                    if ( !exTag) exTag = src;
                    if ( typeof window.ude.modules[ exTag] == "undefined") {
                        window.ude.modules[ exTag] = { src:src, class:className, state:'loading', instance:null, onload:onload};
                    }
                    require( [ path + mod + version] , function( mod) { 
                        console.log( mod);
                        if ( !mod || typeof mod == "undefined") return;
                        let exTag = API.json.value( mod, 'exTag');
                        if ( !exTag) exTag = API.json.value( mod, 'src');
                        let onload = window.ude.modules[ exTag]['onload'];
                        doOnload( onload); 
                        window.ude.modules[ exTag]['state'] = "loaded";
                    }); 
                    window.ude.modules[ exTag]['state'] = "loading";
                } else {
                    console.log( 'loading '+src);
                
                    // onload = window.ud.ude.modules[ src.extag}.instance = exTag+"create"
                    var scriptTag = document.createElement( 'script');
                    // On script elements, onload must be set before src
                    if ( !exTag) exTag = src;
                    scriptTag.id = exTag;                
                    scriptTag.onerror = function()
                    {
                        debug( {level:2}, src+' is not available'); 
                        window.ud.ude.modules[ exTag]['state'] = "unavailable";                    
                    }
                    scriptTag.onload = function() 
                    {
                        let scriptContent = window.ud.ude.dom.element( exTag).textContent;
                        // if ( ["loaded", "complete"].indexOf( script.readyState) > -1)
                        if ( scriptContent.indexOf( "SOILinks error :") > -1)
                        {
                            debug( {level:2}, src+' is not available'); 
                            window.ud.ude.modules[ exTag]['state'] = "unavailable";                    
                        }   
                        else                    
                        {    
                            debug( {level:2}, src+' is loaded (old method)');
                            window.ud.ude.modules[ exTag]['state'] = "loaded";
                            if ( window.ud.ude.modules[ exTag]['onload']) 
                                doOnload( window.ud.ude.modules[ exTag]['onload']);
                            return true;
                        }
                    }
                    let state = "";
                    if ( typeof this.modules[ exTag] != "undefined") state = this.modules[ exTag]['state'];
                    if ( [ "undefined", "unavailable"].indexOf( state) == -1) {
                        scriptTag.src = this.includePath+src.replace( ".js", "")+window.version+".js";;        
                        document.body.appendChild( scriptTag);
                        if ( exTag) this.modules[ exTag] = { state:"loading", onload:onload};
                        else this.modules[ src] = { state:"loading", onload:onload};
                    }    
                }
                return false;
            }
            else
            {                
                let mod = require( '../'+src);
                // window[className] = mod.className;
                if ( className && exTag)
                {
                    let newCl = mod.class; // mod.className;
                    // doOnload( onload.replace( /window.ud.ude/g, 'this').replace( /window.ude/g, 'this').replace( /new[^\(]*\(/, 'new newCl('));
                    let instance = doOnload( onload.replace( /new[^\(]*\(/, 'new '+newCl+'('));                    
                    if ( typeof this.modules[ exTag] != "undefined") {
                        this.modules[ exTag]['state'] = "loaded"; 
                        this.modules[ exTag]['instance'] = instance; 
                    }            
                }
                /*
                else
                {
                    let newCl = mod.class;  //window[className] = mod.class;
                    doOnload( onload.replace( /new[^\(]*\(/, 'new newCl('));
                    if ( typeof this.modules[src] != "undefined") this.modules[ src]['state'] = "loaded";                    
                }                   
                */
                //if ( exTag) this.modules[ exTag]['state'] = "loaded";
                //else if ( typeof this.modules[src] != "undefined") this.modules[ src]['state'] = "loaded";
                //return this.modules[src]['instance'];
            }                
                
        }
    } // UDE.loadScript
    
   /*
    * @api {JS} API.loadCustomModule(src,exTag) Load a module
    * @apiParam {string} src URI of module to load
    * @apiSuccess {boolean} return True if loaded    
    */  
    loadCustomModule( className, exTag)  {
        let src = "modules/custom/"+className.toLowerCase()+".js";
        let onload = "new "+className+"( window.ude.dom, window.ude);";
        this.modules[ exTag] = { src:src, state:"required", onload:onload, className:className, instance:null, exTags:exTag};
        return this.loadScript( src, onload, className, exTag);
    };

   /**
    * 4 - INTERFACE WITH DATA SOURCE (UniversalDoc class)
    */
    
   /**
    * Handle events from VIEW-MODEL
    * @param {string} event created, removed, changed by server,  
    * @param {string} id Id of a saveable element
    * @param {string} onload JS instruction for whene script is loaded
    * @param {string} className Class to instantiate on onload
    * @param {string} exTag Extended tag of HTML elements handled by this module
    * @api {JS} API.dataEVent(event,id) Load a module
    * @apiParam {string} src URI of module to load
    * @apiSuccess {boolean} return True if loaded  
    * @apiGroup Modules    
    */    
    dataEvent( event, id) {
        switch( event) {
            case "created" :
                this.initialiseElement( id);
                break;
            case "changed" :
                this.updateElement( id);
                break;
        }      
   } // UDE.dataEvent()
   
  // Update a table
  updateTable( id, recurrent = false)
  {
    if ( this.tableEd ) this.tableEd.update( id, recurrent);
    else
    {
        // Table editor not loaded so try later
        var me = this;
        setTimeout( function() { me.updateTable( id, recurrent);}, 100);
    }
  } // ude.updateTable()
  

  // Update a saveable/editable element after creation or loading
  // v--2-2 generic approach 
 /**
  * Initialise an element by creating displayable or editable elements as required
  * @param {mixed} elementOrId HTML element to initialise or its ID
  */
  initialiseElement( elementOrId)
  {
    // exTag = this.dom.value( elementId+'...exTag');
    window.UDE_init = true;
    let element = this.dom.element( elementOrId);
    if ( !element) {
        window.UDE_init = false;
        return;
    }
    let exTag = element.tagName.toLowerCase();
    let type = this.dom.attr( element, 'ud_type');
    if (type) exTag += '.'+type;
    //2DO redo, exTag -> module should be in modules
    let gval = this.dom.udjson.value;
    let gvalPath = this.dom.udjson.valueByPath;
    if (  type && gval( UD_exTagAndClassInfo[ exTag], 'useTextEditor')) exTag = "div.linetext";    
    let editor = this.modules[ exTag];
    if ( !editor) return;
    else
    {
        if ( editor.instance) {
            // Use loaded editor
            editor.instance.initialise( element.id);
        } else {
            // Editor not loaded
            // Load if necessary
            let holder = this.dom.element( 'UD_requiredModules');
            let requiredByApp = ( holder) ? this.dom.element( 'UD_requiredModules').textContent : ""
            if ( editor.state == "required" && typeof editor.src != "undefined") {
                let module = editor.src.split('/').slice(-1)[0].split( '.')[0];
                if ( requiredByApp.indexOf( module) == -1)
                    this.loadScript( editor.src, "window.ud.ude.modules['"+exTag+"']['instance']="+editor.onload, editor.className, exTag);
            }
            // Do early/standard initialisation if JSON100format and no HTML provided 
            if ( 
                element.childNodes.length == 1 // more than 1 child element means cached HTML
                && element.childNodes[0].textContent[0] == '{' // quick JON check
                && gval( UD_exTagAndClassInfo[ exTag], 'earlyInit') // config
            ) {
                // Try default initialising
                debug( {level:5}, "Default initialising", element);
                //2DO could use ud_hidden to get hidden content or look for _object                
                // 2022-09-18 - HTML elements require innerHTML here
                //let content = element.childNodes[0].textContent; 
                let content = element.childNodes[0].innerHTML;             
                let json = JSON.parse( content);
                let meta = JSONvalue( json, 'meta');
                if ( meta)
                {                    
                    let id = JSONvalue( meta, 'name');
                    /* 2DO Decide rules on carrying thru styles
                      Currently, leave to CSS selector "div.list.input ul" for example
                      Idea UL_input means input on UL element if found in data
                    // USe container's style to set class names of data
                    let classNames = element.className.replace( type, '').trim();
                    gvalPath( json, 'meta/class', classNames);
                    */
                    let classNames = this.dom.keepPermanentClasses( element.className, true).split( ' ');
                    let editZone = this.dom.udjson.putElement( json, id+'_object',"", classNames[0]);  // could be just sourceId_object (ie jsonOrSource)
                    element.appendChild( editZone);
                    if ( [ 'div.table'].indexOf( exTag) > -1) { this.updateTable( meta.name);}  
                    let divsInEdit = this.dom.elements( 'div', editZone);
                    if ( divsInEdit.length > 1) {
                        divsInEdit[0].classList.add( 'hidden');
                        divsInEdit[1].classList.remove( 'hidden');
                    }
                }
                if ( gval(  UD_exTagAndClassInfo[ exTag], 'needsOwnInit')) {
                    let me = this;
                    setTimeout( function() { me.initialiseElement( element);}, 100); 
                }
            } else {
                // Try to initialise later to give time for module to be loaded
                let me = this;
                setTimeout( function() { me.initialiseElement( element);}, 100); 
            }
        }
        window.UDE_init = false;
    }
  } // ude.initialiseElement()
  
  updateGraphic( id)
  {
    let canvasHolder = document.getElementById( id);
    let dataHolder = this.dom.attr( canvasHolder, 'ude_bind');
    this.draw.renderToCanvas( dataHolder, id);
  } // ude.updateGraphic()
  
  
  // Formula fcts
  getValueFromTable( table, rowIndex, columnName)
  {
   // console.log ("UDE GetValue", table, rowIndex, columnName);
   return this.dom.getValueFromTable( table, rowIndex, columnName);
  } // ude.getValueFromTable()
  
    // Set style on current element
    setStyle( style) {
        debug( { level:1}, "Old call UDE.setSTyle DEPRECATED");
        this.dom.cursor.setStyle( style);
    } // ude.setStyle()

  /**
    * Extract text from a text string (Basic MID)
    * @param {string} str Text 
    * @param {integer} index Start of extraction
    * @param {integer} length Characters to extract
    * @return {string} Extracted text
    * @api {JS} API.substr(str,index,length) Extract text
    * @apiParam {string} str Text 
    * @apiParam {integer} index Start of extraction
    * @apiParam {integer} length Characters to extract
    * @apiSuccess {string} return Extracted text
    * @apiGroup Text or HTML
    */    
    substr( str, index, length) {
        return str.substr( index, length);
    }  
  
  // Change tag of HTML element at cursor
  changeTagOnCurrent( newTagIndex) {
     var newTag = this.dom.availableTags[ newTagIndex].split('.');
     var newUdeType = "";	 
	 if ( newTag.length > 1) newUdeType = newTag[1];
     newTag = newTag[0];	 
     if ( this.dom.cursor.HTMLelement)
     {
        var tag = '';
        var element = this.dom.cursor.HTMLelement;
        var id = element.id;
        this.dom.changeTag( element, newTag, newUdeType);
        element = this.dom.element( id);
        this.dataSource.viewEvent( "changeTag", element);
        if ( newUdeType) this.initialiseElement( id); // so as to upload module ( "create", element);
    }    
  } // changeTagOnCurrent()
  
    // Change tag of an HTML element
  /**
    * Change the tag of an element by index 
    * @param {integer} newTagIndex index in internal list of tags
    * @param {string} elementOrId Id of element
    * @return {string} Extracted text
    */     
    changeTag( newTagOrIndex, elementId, subType = "") {
        let newTag = newTagOrIndex;
        if ( Number.isInteger( newTagOrIndex)) newTag = this.dom.availableTags[ newTagOrIndex].split('.');
        else newTag = newTagOrIndex.split( '.');
        let exTag = newTag.join( '.');
        let newUdeType = "";	 
        if ( newTag.length > 1) newUdeType = newTag[1];
        newTag = newTag[0];
        let element = this.dom.element( elementId);     
        if ( !element) { return null;}
        let id = element.id;
        if ( exTag == "p.undefined") {
            // Removing tag
            if ( this.dom.attr( element, 'exTag') != "p") { element = this.dom.changeTag( element, 'p');}
            if ( element.classList.contains( 'editing')) element.className = "undefined editing"; else element.className = "undefined";
        } else {
            // Adding tag
            let eventType = "changeTag";
            let currentTag = this.dom.attr( element, 'exTag');
            // Update content if default
            // 221223 - hasPanel can then be used for 2nd choices
            let hasPanel = this.dom.elements( 'div.panel-block', element).length;
            let wasUndefined = element.classList.contains( 'undefined');
            if ( wasUndefined || hasPanel) {
                element.classList.remove( 'undefined');
                element.innerHTML = "";
                eventType = "create";
            }
            element = this.dom.changeTag( element, newTag, newUdeType);         
            // Add classes automatically
            let autoClass = $$$.getTagOrStyleInfo( exTag, "autoClass");
            if ( autoClass) {
                if ( !Array.isArray( autoClass)) autoClass=autoClass.split( ' ');
                for( let autoClassi=0; autoClassi < autoClass.length; autoClassi++) element.classList.add( autoClass[ autoClassi]);
            }
            // Adjust content automatically
            $$$.updateContentAfterEvent( element, { eventType:"changeTag", oldTag:currentTag, wasUndefined:wasUndefined});            
            element = this.dom.element( id);
            this.dom.cursor.setAt( element); // !!!important needed to update cursor & shadow cursor to new element
            // Let view-model know about tag change
            let newHasPanel = this.dom.elements( 'div.panel-block', element).length;
            if ( !newHasPanel) this.dataSource.viewEvent( eventType, element);
            if ( subType) this.dom.attr( element, 'ud_subtype', subType);
            // Initialise element
            if ( newUdeType && !newHasPanel) this.initialiseElement( element.id); // so as to upload module ( "create", element);
        }
        // Update floating menu
        if ( this.editElement.id == id) {
            // this.displayFloatingMenu( element);
            this.menuManager.display( element);
        }
        return element;
    } // changeTag()
  
    changeSubType( subType, elementOrId) {
        let element = this.dom.element( elementOrId);
        if ( !element) return debug( { level:3, return:false}, "Can't change subtype on", elementOrId);
        API.dom.attr( element, 'ud_subtype', subType);
        if ( !subType) {
            // Remove class too
            element.className = this.dom.keepTemporaryClasses( element.className);            
        }
    }
  
    // Change class on current element
    changeClassOnCurrent( className) {
        var element = this.dom.cursor.HTMLelement;
        if (!element) return false;
        this.changeClass( className, element);
    } // ude.changeClassOnCurrent()
  
 /**
  * Toggle a class for an element and inform VIEW-MODEL of change
  * @param {string} className Name of the class or class1,class2,class3...
  * @param {string} elementId Id of the element or the element itself
  * @param {string[]} clearClasses List of classes to clear
  * @return {boolean} True if done
  * @api {JS} API.toggleClass(elementOrId,classes) Toggle presence of class on element
  * @apiParam {string} elementId Id of the element or the element itself
  * @apiParam {string} className Name of class to toggle
  * @apiSuccess {boolean} return True if added
  * @apiGroup Elements
  */
  changeClass( className, elementOrId, clearClasses = null, changeChildren = true) {
    let element = this.dom.element( elementOrId);
    if ( !element) return debug( { level:3, return:false}, "Can't change class on", elementOrId);
    // className may have . for multiple classes
    let classNames = [ className];
    if ( className.indexOf( '.')) classNames = className.split( '.');
    let oldClass = ""; 
    if ( clearClasses)
    {    
        // Clear classes
        let clear = clearClasses.split( ',');
        for ( let cleari=0; cleari < clear.length; cleari++) {
            // 2DO Look for mapTo for this class, add to list of clear once!
            if ( element.classList.contains( clear[ cleari])) {
                if ( !oldClass) oldClass = clear[ cleari];
                element.classList.remove( clear[ cleari]);
            }
        }
    } else {
        // Set corresponding default content if element has default content     
        if ( 
            typeof UD_ressources != "undefined"
            && API.hasDefaultContent( element, oldClass)
            && this.dom.keepPermanentClasses( classNames.join( ' '))
        ) {       
            // 2DO use updateContentAFterEvent
            element.innerHTML = API.defaultContent( element, API.getViewType( element), classNames[0]);
            this.dataSource.viewEvent( "changeClass", element); 
        }
    }  
    // Toggle each class in list
    let changed = false;
    for ( let togglei=0; togglei < classNames.length; togglei++)
    {
        
        var className = classNames[ togglei];
        if ( className == "") continue;
        // 2DO Look for mapTo for this class, and to classNames once !
        if ( element.classList.contains( className) && togglei == (classNames.length - 1) ) {
            element.classList.remove( className);
            changed = true;
            if ( !oldClass) oldClass = className;
        } else if ( className.indexOf( ' ') == -1) { /* patch */
            element.classList.add( className);
            changed = true;
        }
    }
    // Remove style span if no significant classes
    if ( this.dom.attr( element, 'exTag') == "span" && this.dom.keepPermanentClasses( element.className) == "") {
        let parent = element.parentNode;
        let previous = element.previousSibling;
        if ( previous && previous.nodeType == Node.TEXT_NODE )  {
            // Merge span text with previous text node and remove span element
            previous.textContent += element.textContent;
            element.remove();
            // Change element being edited and adjust work styles
            element = previous;
            this.editingElement = element;
            this.clearClasses( this.dom.getSaveableParent( element), 'edcontainer');
        }
    }
    // Update floating menu
    /* moved to menu
    if ( changed && [ "editing", "edcontainer", "edinside"].indexOf( className) == -1 && [ "document", "scroll"].indexOf( element.id) == -1) {
        // Update content hook
        API.updateContentAfterEvent( element, { eventType:"changeClass", oldClass:oldClass});
        // Update menu
        // this.displayFloatingMenu( this.dom.getSaveableParent( element));
        this.menuManager.display( this.dom.getSaveableParent( element));
        // Mark element as changed
        this.dataSource.viewEvent( "changeClass", element); 
        // Let editor module know about change
        this.dispatchEvent( { event:"classAdded", type:"classAdded", class:className}, element);
    }
    */
    // Change class inside element
    if ( changeChildren) API.dispatchClassChange( element, oldClass, className);
     
   return changed;    
  } // ude.changeClass()
  // New name
  toggleClass( elementOrId, className)  { 
    return this.changeClass( className, elementOrId);
  }
 /** 
  * @api {JS} API.clearClasses(elementOrId,clearClassesCSV) Clear 1 or more classes
  * @apiParam {string} elementId Id of the element
  * @apiParam {[string]} classesCSV CSV list of classes to clear
  * @apiSuccess {boolean} return True if added
  * @apiGroup Elements    
  */ 
  clearClasses( elementOrId, clearClasses)  { 
    let element = this.dom.element( elementOrId);
    this.changeClass( '', element, clearClasses);
    let children = this.dom.children( element);
    for ( let childi=0; childi< children.length; childi++) { this.changeClass( '', children[ childi], clearClasses);}
  }
  
   /** 
    * @api {JS} API.toggleClasses(elementOrId,classes) Toggle presence of multiple classes on element
    * @apiParam {string} elementId Id of the element
    * @apiParam {[string]} classes Names of classes to toggle
    * @apiSuccess {boolean} return True if added
    * @apiGroup Elements    
    */ 
    toggleClasses( elementOrId, classes) { return this.changeClass( classes.join(','), elementOrId);}
  
    // Insert an element
   /**
    * Create & insert an HTML element, and inform MODEL-VIEW
    * @param {string} tag Tag of HTML element
    * @param {mixed} data Content of element as string, an element to copy or attributes
    * @param {object} attributes Attributes with values  to set in element
    * @param {HTMLelement} at Where to insert, null = cursor
    * @param {boolean} beforeOrAfter Insert before (false, default) or After( true)
    * @param {boolean} inside Insert inside at if true
    * @return {HTMLelement} Inserted HTML element
    * @api {JS} API.insertElement(tag,data,attributes={},at=null,beforeOrAfter=false,inside=false) Insert an element
    * @apiParam {string} tag Tag of HTML element
    * @apiParam {mixed} data Content of element as string, an element to copy or attributes
    * @apiParam {object} attributes Attributes with values  to set in element
    * @apiParam {HTMLelement} at Where to insert, null = cursor
    * @apiParam {boolean} beforeOrAfter Insert before (false, default) or After( true)
    * @apiParam {boolean} inside Insert inside at if true
    * @apiSuccess {HTMLelement} return Inserted element known by MODEL-VIEW
    * @apiError {object} return null
    * @apiGroup Elements
    */           
    insertElement( elementTag, data, attributes={}, at = null, insertAfter = false, inside=false) {
        // Insert element into DOM 
        let newElement = null;
        if ( !at) newElement = this.dom.insertElementAtCursor( elementTag, data, attributes);
        else newElement = this.dom.insertElement( elementTag, data, attributes, at, insertAfter, inside);
        if ( newElement.classList.contains( 'undefined')) {
            let tmpId = "";
            if ( newElement.previousSibling) tmpId = "_AFTER_" + newElement.previousSibling.id;
            else if ( newElement.nextSibling) tmpId = "_BEFORE_" + newElement.nextSibling.id;
            newElement.id = "__TMP" + tmpId + "__";
        } else {    
            // Inform VIEW-MODEL of new element
            this.dataSource.viewEvent( "create", newElement);
            window.UDE_lastInsertId = newElement.id;
            API.paginate( this.dom.getView( newElement.id));
        }
        return newElement;
    } // ude.insertElement()
    
   /**
    * Update a saveable HTML element, and inform MODEL-VIEW
    * @param {mixed} elementOrId The HTML elementto update or its id
    * @param {mixed} html HTML content to place in element
    * @return {HTMLelement} Updateded HTML element
    * @api {JS} API.updateElement(elementOrId,html) Update an element
    * @apiParam {mixed} elementOrId The HTML element to update or its id
    * @apiParam {mixed} html HTML content to place in element
    * @apiSuccess {HTMLelement} return Updated element known by MODEL-VIEW
    * @apiError {object} return null
    * @apiGroup Elements
    */           
    updateElement( elementOrId, html) {
        // Insert element into DOM 
        let element = this.dom.element( elementOrId);
        let saveable = this.dom.getSaveableParent( element)                
        if ( !element ) return debug( {level:3, return:null}, "Can't update ", elementOrId);
        // if ( !isHTML( html)) return debug( {level:2, return:null}, "Bad HTML ", html);
        element.innerHTML = html;
        // Inform VIEW-MODEL of new element
        if ( saveable) this.dataSource.viewEvent( "change", saveable);
        // Check pagination
        API.paginate( this.dom.getView( element));
        return element;
    } // ude.updateElement()
    
    setAttribute( attributeName, value) {
    debug( { level:1}, "Old call UDE.setAttribute DEPRECATED");
    switch( attributeName)
    {
      case "outlineCurrentElementCSS":
        this.dom.cursor.outlineCurrentElementCSS = value;
        break;
   
    }
  }
  
   /**
    * Remove an HTML element, and inform MODEL-VIEW (change or remove)
    * @param {mixed} elementOrId The HTML element to update or its id or selector object
    * @return {HTMLelement} Updateded HTML element
    * @api {JS} API.removeElement(elementOrId,html) Remove an element
    * @apiParam {mixed} elementOrId The HTML element to update or its id
    * @apiSuccess {HTMLelement} return Updated element known by MODEL-VIEW
    * @apiError {object} return null
    * @apiGroup Elements
    */           
    removeElement( elementOrId) {
        let element = this.dom.element( elementOrId);
        if ( !element) return false;        
        let saveable = this.dom.getSaveableParent( element);
        // let view = this.dom.getView( element);
        if ( saveable == element) {            
            // Remove a savable element
            let exTag = this.dom.attr( saveable, 'exTag');
            if ( exTag == "div.part" || exTag == "div.zone") {
                let children = this.dom.children( element);
                for ( let childi=0; childi<children.length; childi++) {                    
                    // Remove saveable children using recurrence
                    this.removeElement( children[ childi]);
                }
                // if view remove from menu
            }
            // Tell UD to delete element
            window.ud.viewEvent( 'delete', element);
        } else if ( element.id.indexOf( 'Zone') > -1) {
            // When do we come here ??
            window.ud.viewEvent( 'delete', element);
        } else { 
            // Remove an HTML element inside a saveable element
            element.remove();
            window.ud.viewEvent( 'change', saveable);            
        }
        // setTimeout( () => API.paginate( view), 1000); // element only dissappears when confirmed by server
        if ( this.editElement) { this.clearClasses( this.editElement, 'editing,edcontainer,edinside');}
    }
  
   /**
    * Give focus to an element and scroll untill visible
    * @param {string} id ID ofelement to get focus
    * @param {mixed} data Content of element as string, an element to copy or attributes
    * @param {object} attributes Attributes with values  to set in element
    * @param {HTMLelement} at Where to insert, null = cursor
    * @param {boolean} beforeOrAfter Insert before (false, default) or After( true)
    * @param {boolean} inside Insert inside at if true
    * @return {HTMLelement} Inserted HTML element
    * @api {JS} API.focus(elementOrId) Put focus on an element
    * @apiParam {string} id ID ofelement to get focus
    * @apiSuccess {HTMLelement} return ELement with focus
    * @apiError {object} return null
    * @apiGroup Elements
    */           
  focus( id) {
    this.dom.cursor.HTMLelement = this.dom.element( id);
    this.dom.cursor.HTMLoffset = 0;
    this.dom.cursor.textElement = this.dom.cursor.HTMLelement.firstChild;
    this.dom.cursor.textOffset = 0;
    this.dom.cursor.set();
	// Make sure element is visible
    var sy = this.dom.cursor.HTMLelement.offsetTop;
    if (sy > 200) this.container.parentNode.scrollTop = sy-200;
    else this.container.parentNode.scrollTop = 0;
  } // 
  
   /**
    * Setup editing on an element
    */  
    edit( elementOrId = "") {
        let processed = false;
        if ( !elementOrId) elementOrId = this.dom.cursor.fetch().HTMLelement;
        let element = this.dom.element( elementOrId);
        if ( !element || element == this.editElement) return processed;
        let edit = true;
        if ( !this.dom.attr( element, 'editable')) edit = false;
        if ( edit) {
            // Activate 2 stage editing if appropriate
            if ( 
                element 
                && element.nodeType == Node.ELEMENT_NODE
                && element.className.indexOf( "Noedit") == -1
                && this.dom.parentAttr( element, 'onclick') == ""
                && this.dom.parentAttr( element, 'tagName') != "a"
            ) {
                // Removing editing from current element
                if ( this.editElement) { this.clearClasses( this.editElement, 'editing,edcontainer,edinside');}
                this.editElement = null;
                // this.displayFloatingMenu();
                this.menuManager.hide();
            }
        }
        // Give editor module a chance to handle the event and break if processed 
        let e = { event:"focus", type: "focus"};
        if ( !processed) processed = this.dispatchEvent( e, element);
        this.requires2stageEditing( element);
        if ( edit && !processed && this.dom.extraAttr( element, 'ude_menu') != "off")  {
            // Display floatable menu
            let saveable = this.dom.getSaveableParent( element);
            let editable = this.dom.getEditableParent( element);
            this.toggleClass( saveable, 'editing');
            this.clearClasses( saveable, 'edcontainer');
            this.clearClasses( element, 'edinside');
            if (  this.dom.attr( editable, 'exTagType') == "span" && !editable.classList.contains( 'caption')/*&& saveable != editable*/) { 
                this.toggleClass( saveable, 'edcontainer');
                this.toggleClass( element, 'edinside');
            }
            this.editElement = saveable;
            // this.displayFloatingMenu( this.dom.getEditableParent( element));
            this.menuManager.display( this.dom.getEditableParent( element));            
        }
        return processed;
    } // edit()

  // Set an element as changed with ticks
   /**
    * Handle a change in the text content of an element
    * @param {string} elem The element whose text content has changed
    * @param {boolean} forceSave Force informing VIEW-MODEL to provoke saving
    * @return {HTMLelement} Inserted HTML element
    * @api {JS} API.focus(elementOrId) Put focus on an element
    * @apiParam {string} id ID ofelement to get focus
    * @apiSuccess {HTMLelement} return ELement with focus
    * @apiError {object} return null
    * @apiGroup Elements
    */           
    setChanged( elementOrId, forceSave = false) {
        let elem = this.dom.element( elementOrId);
        if ( typeof elem == "undefined") {
            // If no element provided then use cursor
            this.dom.cursor.fetch();
            elem = this.dom.cursor.HTMLelement;
        } 
        if ( !elem) return null;
    
        // 2DO elem should be changed table
        // Let editor module know about the change
        this.dispatchChangeEvent( elem);
    
        // Let calculator know about the change
        this.calc.checkDependencies( elem);
    
        // Let rollbacker know about the change No doing this in key event and 2stage editing to get previous content
        // if ( window.rollbacker) window.rollbacker.inputEvent( {event:"change"}, elem);
        
        // Check pagination
        API.checkPagination( elem);
        
        // 2DO if composite and change is in element name then change names (could be an attribute)

        // Check if modified element or parent has auto-save disabled
        if (  !forceSave && this.dom.parentAttr( elem, "ude_autosave").toLowerCase() == "off") {
            // Don't mark as changed if auto-save (ude_autosave) is off
            debug( {level:3}, "Auto update disabled on "+this.dom.cursor.HTMLelement.id);
            return;
        }
        // Get element's context
        let saveable = this.dom.getSaveableParent( elem);
        saveable.classList.remove( 'modified');
        // Trial pseudo for temporary elements such as unconfigured view
        if ( this.dom.attr( saveable, 'ud_oid') == "__NONE__") return null;
        // this.reFloatConfig( saveable);
        let displayable = this.dom.getParentWithAttribute( 'ude_bind', elem);   
        let target = this.dom.element( this.dom.attr( displayable, 'ude_bind'));
        let udtype = this.dom.attr( saveable, 'ud_type');    
        if ( target && udtype) {
            // Modified element is binded to another element, so update this target element
            if (  this.dispatchEvent( {event:'save', target:target}, displayable))
                return this.dataSource.viewEvent( "change", saveable); // this.setChanged( saveable);    
        } else {
           // Let VIEW-MODEL know about the change
            return this.dataSource.viewEvent( "change", saveable);
        }
        return null;
    } // UDE.setChanged()
  
   /**
    * Dispatch an Edit event
    * @param {elementOrId} element Element where the event was generated
    * @param {object} eventOrJSON The edit event as object or JSON
    * @param {boolean} True of processed
    */    
    /*
    *  IDEA 3rd paramater data could be "this" in buttons => add data in event as data.textContent or innerHTML
    */
    dispatchEditEvent( eventOrJSON, elementOrId) {
        let element = this.dom.element( elementOrId);
        let event = ( typeof eventOrJSON == "string") ? this.dom.udjson.parse( eventOrJSON) : eventOrJSON;
        let processed = false;
        if ( element && event) { 
            if ( typeof event.type != "undefined" && typeof event.event == "undefined") event.event  = event.type; // editors use event attribute
            let saveable = this.dom.getSaveableParent( element);        
            let exTag = this.dom.attr( saveable, 'exTag');
            if (  this.dom.udjson.value( UD_exTagAndClassInfo[ exTag], 'useTextEditor')) exTag = "div.linetext";
            let editor = this.modules[ exTag];
            if ( editor && editor.instance) processed = editor.instance.inputEvent( event, element);   
            if ( !processed) processed = this.editEventDefault( event, element);
        }
        return processed;
    } // UDE.dispatchEditEvent()

    // Dispatch event
    dispatchEvent( event, element) {
        if ( !element) return;
        if ( typeof event.type != "undefined" && typeof event.event == "undefined") event.event  = event.type; // editors use event attribute
        let processed = false;
        // Find container
        let saveable = this.dom.getSaveableParent( element);
        let exTag = this.dom.attr( saveable, 'exTag'); 
        if (  this.dom.udjson.value( UD_exTagAndClassInfo[ exTag], 'useTextEditor')) exTag = "div.linetext";
        else if ( this.dom.parentAttr( element, 'ud_type') == "linetext") exTag = "div.linetext";
        let editor = this.modules[ exTag];
        if ( editor && editor.instance) processed = editor.instance.inputEvent( event, element);        
        if ( !processed) processed = this.editEventDefault( event, element);
        return processed;
    }
    // Dispatch change event
    dispatchChangeEvent( element)
    {
        // Non-composite juste modify element
        // Composite
        /*
        var container = this.dom.getParentWithAttribute( "ude_bind", element);
        if (!container) return;
        var target = null;
        var targetId = container.getAttribute( 'ude_bind');
        if ( targetId) target = document.getElementById( targetId);
        */
        let container = this.dom.getParentWithAttribute( "ude_bind", element);
        let target = this.dom.getSaveableParent( element);
        if (!target) return;
        var udtype = this.dom.getParentAttribute( '', 'ud_type', target);
        // Define event
        let event = {source:element, container:container, target:target, event:"change"};        
        // Dispatch according to ud_type
        if ( target && udtype)
        {
            switch ( udtype)
            {
                case "table" :
                    this.tableEd.inputEvent( event, element); // container);
                    break;
                case "list" :
                    let editor = this.modules[ 'div.list'].instance;
                    if (editor) editor.inputEvent( event, element);
                    break;
                case "graphic" :
                    this.draw.inputEvent( event, element); // container);
                    break;
                case "linetext" :
                case "server" :
                case "css" :
                case "js" :
                case "apiCalls" :
                case "json" :
                    this.textEd.inputEvent( event, container);
                    break;
                case "html" :                 
                case "chart" :
                    this.dispatchEvent( {event:event, target:target}, element);
                    break;
                default :    
                    break;
            }
        }
    } // UDE.dispatchChangeEvent()
  
   /**
    * @api {JS} API.insertTextAtCursor(html) Insert text at cursor and mark element as changed
    * @apiParam {string} html HTML code to insert
    * @apiParam {mixed} at Id of element where to insert after or the HTML element itself
    * @apiGroup Elements
    */
    insertTextAtCursor( text, type) {
        //this.dom.cursor.fetch();
        let element = this.dom.cursor.textElement;
        let offset = this.dom.cursor.textOffset;
        let content = element.textContent;
        let placeholder = this.dom.attr( element.parentNode, 'ude_place');
        if ( content == placeholder) {
            element.textContent = text;
        } else {
            element.textContent = content.substring(0, offset)+text+content.substring(offset, content.length);
        }
        // 2DO could use textEditorAttr
        if ( this.dom.getParentAttribute( "", "ude_autosave", this.dom.cursor.HTMLelement) == "off")
            debug( {level:3}, "Auto update disabled in insertTextAtCursor on "+this.dom.cursor.HTMLelement.id);
        else  
           this.setChanged( this.dom.cursor.HTMLelement);
    } // UDE.inertTextAtCursor
  
   /**
    * @api {JS} API.insertHTMLAtCursor(html) Insert HTML at cursor and mark element as changed
    * @apiParam {string} html HTML code to insert
    * @apiParam {mixed} at Id of element where to insert after or the HTML element itself
    * @apiGroup Elements
    */
    insertHTMLatCursor( html, type)
    {
        //this.dom.cursor.fetch();
        let element = this.dom.cursor.HTMLelement;
        let offset = this.dom.cursor.HTMLoffset;
        let content = element.innerHTML;
        let placeholder = this.dom.attr( element, 'ude_place');
        if ( content == placeholder) { 
            element.innerHTML = html;
            this.dom.cursor.setAt( element, 9000);
        }
        else {
            let initialLength = element.innerHTML.length;
            element.innerHTML = content.substring(0, offset) + html + content.substring(offset, content.length);
            this.dom.cursor.setAt( element, offset + element.innerHTML.length - initialLength)
        }
        if ( this.dom.getParentAttribute( "", "ude_autosave", element) == "off")
            debug( {level:3}, "Auto update disabled in insertTextAtCursor on "+this.dom.cursor.HTMLelement.id);
        else  
            this.setChanged( element);
    } // UDE.inertTextAtCursor
  
   /**
    * Return true if element requires 2-stage editing after setting up editing, otherwise return false. Abandon any ongoin 2 stage eduting.
    * @param {HTMLelement} element The element to test
    * @return {boolean} True if 2 stage editing setup otherwise false
    */     
    requires2stageEditing( element) {
        // If already editing and another element, abandon editing on previous element
        if ( this.editingElement && this.editingElement != element) this.leave2stageEditing( true);
        // If already editing this element return true
        if ( this.editingElement && ( this.editingElement == element || this.editingElement == element.parentNode)) return true;
        // Use 2 stage editing if the element or its parent have ude-stage=on, has text children, element has a formula or an _onclick field
        // 2DO dom.hasTextNode();
        let children = element.childNodes; // this.dom.children( element);
        let textChild = false;
        for ( let childi=0; childi < children.length; childi++) {
            if ( children[ childi].nodeType == 3) {
                textChild = true;
                break;
            }
        }
        //if ( !textChild) return false;
        let stageEditing = this.forceStagedEditing;
        stageEditing |= API.testEditorAttr( element, 'ude_stage') //(this.dom.parentAttr( element, 'ude_stage') == "on");
        stageEditing |= (this.dom.attr( element, 'ude_formula') != ""); //!!!IMPORTANT 2022-05-13 TD's still need ud_stage
        stageEditing |= (this.dom.attr( element, '_onclick') != "" || this.dom.attr( element, 'ude_onclick') != "");
        // Unless contenteditable is set to false
        if ( stageEditing && this.dom.isEditable( element)) { // this.dom.attr( element, 'editable')) {
            // Setup 2 stage editing on this element
            // Save element and its current content
            this.editingElement = element;
            this.editRestoreHTML = element.innerHTML;
            this.editRestoreAttr = { "ude_onclick":"", "ude_formula":""};
            // Prepare for editing based on type and presence of a formula
            let type = this.dom.attr( element, 'ud_type');
            let formula = this.dom.attr( element, 'ude_formula');
            // Check parent if neither type or formula
            let tag = this.dom.attr( element, 'exTagType');
            if ( !type && !formula) {                
                // Check parent
                let parent = element.parentNode;
                if ( this.dom.attr( element, 'exTagType') != "span"
                     && ( this.dom.attr( parent, 'ud_type') || this.dom.attr( parent, 'ude_formula'))) {
                    element = parent;
                    type = this.dom.attr( element, 'ud_type');
                    formula = this.dom.attr( element, 'ude_formula');                    
                    this.editingElement = element;
                    this.editRestoreHTML = element.innerHTML;
                    this.editRestoreAttr = {};
                }
            } 
            // Set editing styles on element
            element.classList.add( 'stageediting'); 
            // 2DO Handle just created spans (so no _onclick for example)               
            if  ( type == "button") { //} && this.mode.indexOf( 'edit') === 0) { //&& this.dom.attr( element, '_onclick')) {
                // Edit a button DO|script|prompt|test
                let buttonEdit = "";
                // 2DO Build list of available local functions
                buttonEdit += "DO|"+this.dom.attr( element, "_onclick")+"|"+ element.innerHTML;
                buttonEdit += '|<a href="javascript:" onclick="'+this.dom.attr( element, '_onclick')+'">test</a>';
                element.innerHTML = buttonEdit;
                this.editRestoreAttr = { ude_onclick: this.dom.attr( '_onclick'), ude_formula: this.dom.attr( 'ude_formula')};
                //element.setAttribute( 'onclick', "");
            } else if ( type == "link") {
                // Edit a link =formula to build link|test
                let anchor = this.dom.element( 'a', element);
                let link = "";
                if ( anchor) link = this.dom.attr( anchor, 'href');
                let formula = this.dom.attr( element, 'ude_formula');
                if ( !formula) formula = "linkTag( '"+link+"','','"+element.textContent+"');";
                element.innerHTML = "="+formula;
                if ( link) element.innerHTML += ' | <a href="javascript:" onclick="window.open(\''+link+'\');">test</a>';             
            } else if ( type == "field" && !this.mode == "edit3" && this.calc.countTermsInFormula( this.dom.attr( element, 'ude_formula')) == 1) { 
                // Field linked directly to an element -- use as input field 
                if ( !textChild) {
                    if ( element.childNodes[0].tagName.toLowerCase() == "img") {
                        // Choose an image
                        element.style.border = "2px solid green";
                        textChild = document.createTextNode( "select in clipboard");
                        textChild = element.appendChild( textChild);
                        this.dom.cursor.HTMLelement = element;
                        this.dom.cursor.textElement = textChild;
                        this.dom.cursor.textOffset = 0;
                        this.dom.cursor.set();
                    }    
                }
                // If check then clear on 1st char = ude_place
            } else if ( type == "field" && this.mode == "edit3") {     
                // Element with a formula display =formula
                if ( !textChild) {
                    this.dom.emptyElement( element);
                    textChild = document.createTextNode( "");
                    textChild = element.appendChild( textChild);
                }
                element.textContent = "="+this.dom.attr( element, 'ude_formula'); // + ' <a href="'test";
            } else if ( this.dom.attr( element, 'ude_formula')) {
                // Element with a formula display =formula
                if ( !textChild) {
                    this.dom.emptyElement( element);
                    textChild = document.createTextNode( "");
                    textChild = element.appendChild( textChild);
                }
                element.textContent = "="+this.dom.attr( element, 'ude_formula'); // + ' <a href="'test";
            }
            return true;
        }
        return false; 
    } // UDE.requires2stageEditing()
    
   /**
    * Return true if element is in 2 stage editing otherwise false
    * @param {HTMLelement} element The element to test
    * @return {boolean} True if 2 stage editing setup otherwise false
    */     
    is2stageEditing( element) {
        return ( this.editingElement == element);
    } // UDE;is2StageEditing()

   /**
    * Leave 2 stage editing on currently edit element and generate Changed event if validated
    * @param {boolean} validate If True, store edit value to element otherwise restore
    * @return {boolean} True if 2 stage editing setup otherwise false
    */         
    leave2stageEditing( validate = true)
    {
        if ( !this.editingElement) return false;
        // Get edited content and clear editing mode
        let editingElement = this.editingElement;
        this.editingElement = null;                
        editingElement.classList.remove( 'stageediting');   
        let content = editingElement.textContent;
        if ( validate) {
            // Check content
            let checkFct = this.dom.attr( editingElement, 'ude_check');
            if ( checkFct && !this.calc.checkValue( checkFct, content)) { validate = false;}
        }
        if ( validate) {
            //
            let save = true;
            // Inform Rollback function
            if ( window.rollbacker) window.rollbacker.inputEvent( {event:"change", content:this.editRestoreHTML}, editingElement); 
            let type = this.dom.attr( editingElement, 'ud_type');
            let formula = this.dom.attr( editingElement, 'ude_formula')
            if ( content.charAt(0) == '=') {
                // Edited content is a formula                
                content = content.substr(1).split( '|');
                this.dom.attr( editingElement, "ude_formula", content[0]);
                editingElement.textContent = this.dummy;
                this.dom.attr( editingElement, "_onclick", "__CLEAR__");
                this.calc.updateElement( editingElement);
                // Don't save child elements generated by formula in JSON100 as they will be regenerated
                this.dom.attr(
                    editingElement,
                    'ud_follow', 
                    ( this.dom.children( editingElement)) ? 'off' : '__CLEAR__'
                );
            } else if ( type == "field" && this.calc.countTermsInFormula( formula) == 1) {
                // Field linked directly to an element -- set value in linked element
                let path = formula;
                if ( formula.indexOf( '(')) { path = path.substring( path.indexOf( '(')+1, path.length-1).trim();}
                path = path.split( '.');
                let bindedRoot = this.dom.element( path[0]);
                // 2DO if editingElement contains single image then content = src
                if ( editingElement.childNodes.length == 2 && editingElement.childNodes[0].tagName.toLowerCase() == "img") {
                    content = this.dom.attr( editingElement.childNodes[0], 'src');
                    editingElement.style.border = "none";
                }
                let event = { event:"setValue", key:[ path[1], path[ 2]], value:content};
                this.dispatchEvent( event, bindedRoot);
                this.calc.updateElement( editingElement);
                if ( this.dom.attr( editingElement, 'ude_menu') == "off") save = false;
                // move to table bindedElement.textContent = content;
            } else if ( content.substr( 0, 3) == 'DO|') {
                // Edited content is a button or link instruction, syntax DO|JS click instruction|Link or button text|link to|test              
                content = content.substr( 3).split('|');
                let instr = stripScriptsAndStyles( content[0]);
                let label = API.translateTerm( content[ 1], false);
                if ( instr.charAt(0) == '=') {
                    // JS click instruction is a formula
                    instr = instr.substring(1);
                    this.dom.attr( editingElement, "onclick_formula", instr);
                    editingElement.setAttribute( "_onclick", this.calc.exec( instr, editingElement));
                }  
                else editingElement.setAttribute( "_onclick", instr);
                this.dom.attr( editingElement, "ude_formula", "__CLEAR__");
                editingElement.textContent = content[1];
                this.dom.clearAttr( editingElement, 'ude_formula');
                this.calc.updateElement( editingElement);                
            } else {
                // Edited content is plain text
                this.dom.attr( editingElement, "ude_formula", "__CLEAR__");
                this.dom.attr( editingElement, "ud_follow", "__CLEAR__");
                this.dom.attr( editingElement, "_onclick", "__CLEAR__");
                let validateExpr = this.dom.attr( editingElement, 'ude_validate');
                if ( validateExpr) {
                    validateExpr = validateExpr.replace( /this/g, editingElement.innerHTML);
                    if ( !this.calc.eval( validateExpr, editingElement)) {
                        save = false;
                        editingElement.innerHTML = this.editRestoreHTML;
                    }
                }
            }
            // ude_onvalid hook
            let code = this.dom.attr( editingElement, 'ude_onvalid');
            if ( save && code) {
                if ( editingElement.id) { code = code.replace( /{id}/g, editingElement.id);}
                doOnupdate( code);
            } 
            // Change event if content or attributes have changed          
            if ( 
              save
              && ( 
                editingElement.innerHTML != this.editRestoreHTML
                || this.dom.attr( editingElement, '_onclick') != this.editRestoreAttr.ude_onclick
                || this.dom.attr( editingElement, 'ude_formula') != this.editRestoreAttr.ude_formula
              )
            ) this.setChanged( editingElement);
            /*
            {
                // 2DO use getParentWithAttribute
                if ( this.dom.attr( editingElement, "ud_oid") == "") this.setChanged( editingElement.parentNode); 
                else this.setChanged( editingElement);
            }
            */
        }
        else 
        {   
            // Edited text not validated so restore    
            editingElement.innerHTML = this.editRestoreHTML;
            //for ( var keyA in this.editRestoreAttr) editingElement.setAttribute( keyA, this.editRestoreAttr[ keyA]);
            if ( !this.floaterActionPending) {
                if ( this.dom.attr( editingElement, 'exTag') == "span.field") { editingElement.style.border = "none";}
                // Get saveable and remove edinside/edcontainer
                let saveable = this.dom.getSaveableParent( editingElement);
                this.clearClasses( saveable, 'edcontainer');
                this.clearClasses( editingElement, 'edinside');
                this.dom.cursor.setAt( saveable);
                // ude_oninvalid hook
                let code = this.dom.attr( editingElement, 'ude_oninvalid')
                if ( code && editingElement.id) { doOnupdate( code.replace( /{id}/g, editingElement.id));}
            }
        }
        this.editingElement = null;
        this.editRestoreHTML = "";
        this.editRestoreAttr = {};
        if ( this.isMobile || this.forceStagedEditing) {
            document.activeElement.blur();
            if ( this.menuManager) this.menuManager.hide();
        }
        return true;
    }  // UDE.leave2stageEditing  
    
    // Form input controller
   /**
    * Provide Placholder functionnality on input field OBSOLETE Keep for suggestions
    * @param {HTMLelement} element Input element on which to manage input
    * @param {object} e Key event
    */             
    formInputChange( element, e=null) {
        // Find form
        let form = element.parentNode; // 2DO  multiple levels
        
        // Special keys
        if (e && e.keyCode < 20) {
            if ( e.code == "Enter") form.submit();
            else if( e.code != "Backspace" && e.code != "Delete") return; 
        } 
        debug( {level:1}, "formInputChange used", element);
        // if initialised and text != value then class=changed and
        if ( this.ticks > 50 && element.classList.contains("initialField")) {
            // Change style to editField
            element.value = "";
            element.classList.remove("initialField");
            element.classList.add("editField");
        }
        else if ( element.value == "") // 220504 - try && this.dom.attr( element, 'placeholder'))
        {
            // Restore initial value and style
            // 220504 - try element.value = element.defaultValue;
            element.classList.remove("editField");
            element.classList.add("initialField");
           
        }  
        // Look up element.value in suggestions, display suggestions     
        // 2DO Try  https://github.com/kraaden/autocomplete/blob/master/readme.md       
    } // UDE.formInput()
    
    /**
    * Inline command management
    * @param {string} key Key that has been pressed
    * @return {boolean} True if ket used by inline command manager, False otherwise
    */
    inlineCommandManager( key) {
        if ( this.commandMode) {
            // Currently in command mode - test fro abandon or validate
            if ( key == "Escape") 
            {
                // Abandon command mode
                this.commandMode = false;
                this.command  = "";
                return true;
            }
            else if ( key == "Enter")
            {
                // Check command
                // Send API request
                // Leave command mode
                this.commandMode = false;
                this.command = "";
                return true;
            }
            else
            {
                this.command += key;
                // Update display
                return true;
            }
        } else {
            // Currently not in command mode - test for start command sequence
            if ( this.lastChar == this.enterCommand.charAt(0) && key == this.enterCommand.charAt(1))
            {
                // Enter command mode
                console.log( "Command mode");
                // Rollback last character
                // Turn saving off ie no setChanged
                // 
                this.commandMode = true;
                this.command = "";
                return true;
            }
            else if ( key == this.enterCommand.charAt(0))
            {
                // 1st character of command mode
                this.lastChar = key;
                return false;            
            }
        }    
        return false;

    } // UDE.inlineCommandManager()
    
   /**
    * Move an element in line with window scrolling
    * @param {string} elementId The element to move with scroll
    */
    followScroll( elementId)
    {
        if ( !elementId)
        {
            this.emulateMobile = false;
            this.elementToScroll = null;
            this.lastClickPosition = {x:-1, y:-1}; 
            let me = this;
            this.dom.topElement.removeEventListener('mousemove', function (event) { me.pointEvent( event);});            
        }
        else
        {
            let element = this.dom.element( elementId);
            if ( !element) return;
            this.emulateMobile = true;
            this.elementToScroll = element; 
            let me = this;
            this.dom.topElement.addEventListener('mousemove', function (event) { me.pointEvent( event);});
            this.dom.cursor.HTMLelement = element.childNodes[0];            
        }
    } // UDE.followScroll()
    
  
   /*
    *  USER EVENT MANAGEMENT
    */ 
    arrowNavigate( direction) {
        // Set current element and offset
        switch (direction) {
            case 2: 
                this.dom.moveCursor(1, null, "line");
                break;
        case 3:
                this.dom.moveCursor(-1);
                break;
        case 4:
            this.dom.moveCursor(1);
            break;
        }   
    } // navigate()

  click( element)
  {
  } // click()
  
  /*
   * UTILITIES
   */
    getEditType( element) {
        let editable = this.dom.getEditableParent( element);
        let editableType = this.dom.attr( editable, 'ud_type').toLowerCase();    
        if ( [ 'editzone', 'viewzone'].indexOf ( editableType) > -1) { 
            editableType = this.dom.attr( editable, 'ud_subtype');
        }
        let editType = "html";
        if ( [ "text", "linetext", "css", "js", "json", "htmltext", "html", "chart"].indexOf( editableType) > -1) { editType = "text";}
        return editType;
    }
  
    clearPlaceholder( elementOrId) {
        let element = API.dom.element( elementOrId);
        let placeHolder = API.getEditorAttr( element, 'ude_place');//API.dom.attr( element, 'ude_place');
        if ( ( !placeHolder && element.textContent == "...") || element.textContent == placeHolder) {
            element.textContent = "";
        }
        element.classList.remove( 'placeHolding');
    }
    setPlaceholder( elementOrId) {
        let element = API.dom.element( elementOrId);
        let placeHolder = API.getEditorAttr( element, 'ude_place');//API.dom.attr( element, 'ude_place');
        if ( placeHolder && element.textContent == "") {
            element.textContent = placeHolder;
        }
        element.classList.add( 'placeHolding');
    }
   /**
    * Return true if element has default content
    * @param {HTMLelement} elementOrId The HTML element or its id
    * @return {boolean} True if content is 'placeholder'
    */
   /** 
    * @api {JS} API.hasDefaultContent(elementOrId) Return true if element has default content
    * @apiParam {HTMLelement} elementOrId The HTML element or its id
    * @apiSuccess {boolean} True if content is 'placeholder'
    * @apiGroup HTML
    */     
    hasDefaultContent( elementOrId) {
        let element = this.dom.element( elementOrId);
        // Get default content to compare with        
        let defaultContent = this.dom.udjson.value( UD_defaultContentByExTag, this.dom.attr( element, 'exTag')); 
        if ( !defaultContent) { defaultContent = "...";}
        return ( 
            element.classList.contains('initialcontent') 
            || API.getEditorAttr( element, 'ude_place') /*this.dom.attr( element, 'ude_place')*/ == element.innerHTML
            || ( defaultContent && element.innerHTML == defaultContent)             
        );
    }  // DOM.hasDefaultContent()

 

} // Class UDE

if ( typeof process == 'object')
{
    // Testing under node.js
    testThis = false;
    // Load modules associated with UDE
    const udecalc = require( "../app/calculator/udecalc.js");
    const UDEcalc = udecalc.UDEcalc; 
    window.UDEcalc = udecalc.UDEcalc;        
    module.exports = { UDE: UDE, CALC: window.UDEcalc};
    window.UDE = UDE;    
    if ( typeof global.JSDOM == "undefined" && typeof window == "undefined")
    {
        // Auto-test module
        // Setup test environment
        var envMod = require( '../tests/testenv.js');
        envMod.load();
        // Load additionnal modules required for test
        const udedraw = require( "../../app/elements/udedraw.js");
        const UDEdraw = udedraw.UDEdraw; 
        window.UDEdraw = udedraw.UDEdraw;    
        //console.log( typeof global.JSDOM);
        // Test this module
        console.log( 'Syntax OK');
        console.log( 'Start of UDE test program');
        // Setup browser emulation
        debug( {level:2}, "abd");
        console.log( 'Creating ude');
        var myude = new UDE( document.getElementById('document'), null, 0);
        console.log( "Test completed");
    }

} // End of test routine
